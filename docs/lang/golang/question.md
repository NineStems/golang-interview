##  Вопросы по языку Golang

### 1. Что из себя представляет тип данных string в языке Golang? Можно ли изменить определенный символ в строке? Что происходит при склеивании строк?

Строка Go - это байтовый срез, предназначенный только для чтения, который может содержать байты любого типа и иметь произвольную длину. Строка неизменяемая и изменить определенный символ в конкретной строке нельзя. Создается новая строка (в простейшем случае).

### 2. Как эффективно склеивать множество строк?

Например, чтобы избавиться от лишних аллокаций, можно воспользоваться типом strings.Builder и методом WriteString:
```go
 func join(strs ...string) string {
    var sb strings.Builder
    for _, str := range strs {
            sb.WriteString(str)
    }
    return sb.String()
 }
 ```
И никто не мешает пользоваться пакетом strings.

### 3. Как устроен тип карты? Что такое эвакуация?
Хеш-табли́ца — это **структура данных, реализующая интерфейс ассоциативного массива**, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу. Важное свойство хеш-таблиц состоит в том, что, при некоторых разумных допущениях, все три операции (поиск, вставка, удаление элементов) в среднем выполняются за время O(1). Но при этом не гарантируется, что время выполнения отдельной операции мало́.

Порядок итераций по отображению не определен; различные реализации могут использовать разные хеш-функции, что приведет к иному порядку. На практике получается случайный порядок, который варьируется от одного запуска программы к другому. Это сделано преднамеренно; варьируемые последовательности помогают писать программы, которые одинаково надежны в разных реализациях языка.

```golang
// A header for a Go map.
type hmap struct {
	// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
	// Make sure this stays in sync with the compiler's definition.
	count     int // # live cells == size of map.  Must be first (used by len() builtin)
	flags     uint8
	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
	hash0     uint32 // hash seed

	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

	extra *mapextra // optional fields
}
```

Мапа в Go — это просто указатель на структуру hmap. Это и является ответом на вопрос, почему при том, что мапа передается в функцию по значению, сами значения, лежащие в ней меняются — все дело в указателе. Так же структура hmap содержит в себе следующее: количество элементов, количество «ведер» (представлено в виде логарифма для ускорения вычислений), seed для рандомизации хэшей (чтобы было сложнее заddosить — попытаться подобрать ключи так, что будут сплошные коллизии), всякие служебные поля и главное указатель на buckets, где хранятся значения. Поле buckets — хранилище пар ключ-значение, таких «ведер» несколько, в каждом лежит 8 пар. Сначала в «ведре» лежат слоты для дополнительных битов хэшей (e0..e7 названо e — потому что extra hash bits)

Свойство oldbuckets в структуре мапы необходимо во время процесса миграции данных.  
Миграция начинается при принятии решения о слишком большом кол-ве данных в бакетах. При этом текущение значение указателя buckets сохраняется в свойство oldbuckets, после чего в свойстве buckets создается новая структура бакетов, где их становится в 2 раза больше от текущего. Данные мапы копируются из oldbuckets в buckets.  
Т.к. бакетов становится в 2 раза больше, кол-во бакетов всегда равно степени числа 2.
Именно поэтому в структуре мапы есть свойство B — это степерь двойки, которая показывает кол-во бакетов.

По хэш функции определяется в какое «ведро» мы кладем значение, внутри каждого «ведра» может лежать до 8 коллизий, в конце каждого «ведра» есть указатель на дополнительное, если вдруг предыдущее переполнилось.

Поиск, если разобраться, устроен не так уж и сложно: проходимся по цепочкам «ведер», переходя в следующее, если в этом не нашли. Поиск в «ведре» начинается с быстрого сравнения дополнительного хэша (вот для чего эти e0...e7 в начале каждого — это «мини» хэш пары для быстрого сравнения). Если не совпало, идем дальше, если совпало, то проверяем тщательнее — определяем где лежит в памяти ключ, подозреваемый как искомый, сравниваем равен ли он тому, что запросили. Если равен, определяем положение значения в памяти и возвращаем. Как видите, ничего сверхъестественного.

Хеш-функция тем лучше, чем равномернее она распределяет исходные значения по корзинам. Но даже хорошая функция будет иногда давать одинаковый результат для разных входных значений — это называется коллизией. Так что в одной корзине могут оказаться TID-ы, соответствующие разным ключам, и поэтому полученные из индекса TID-ы необходимо перепроверять.

### 4. Какие нюансы при работе с картами в многопоточном режиме?
`// todo`

### 5. Расскажите про многопоточность в golang?
Многопоточность в golang реализована с помощью Горутин.  

Подпрограмма или Горутина (goroutine) — это функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве.  
Каждая занимает в среднем 4kb.

Каждый поток операционной системы имеет блок памяти фиксированного размера (зачастую до 2 Мбайт) для стека — рабочей области, в которой он хранит локальные переменные вызовов функций, находящиеся в работе или приостановленные на время вызова другой функции.  
Такой стек фиксированного размера является одновременно слишком большим и слишком малым.  
Стек размером 2 Мбайта оказывается огромной тратой памяти для небольшой go-подпрограммы, которая, например, просто ожидает WaitGroup, а затем закрывает канал.   
Для программ Go не редкость одновременное создание сотен тысяч go-подпрограмм, что было бы невозможно с такими большими стеками. Тем не менее стеков фиксированного размера, несмотря на их большие размеры, не всегда достаточно для сложных и глубоко рекурсивных функций.  
Изменение фиксированного размера стека может повысить эффективность использования памяти и позволить создавать большее количество потоков или разрешить включать рекурсивные функции с большей глубиной, но не может одновременно обеспечить и то, и другое.

В противоположность этому go-подпрограмма начинает работу с небольшим стеком, обычно около 2 Кбайт.  
Стек go-подпрограммы, подобно стеку потока операционной системы, хранит локальные переменные активных и приостановленных функций, но, в отличие от потоков операционной системы, не является фиксированным; при необходимости он может расти и уменьшаться.  
Максимальный размер стека go-подпрограммы может быть около 1 Гбайта, на порядки больше типичного стека
с фиксированным размером, хотя, конечно, такой большой стек могут использовать только несколько go-подпрограмм.

Канал представляет собой механизм связи, который позволяет одной go-подпрограмме отправлять некоторые значения другой go-подпрограмме.  
Каждый канал является средством передачи значений определенного типа, который называется типом элементов канала.  
Тип канала, элементы которого имеют тип int, записывается как chanint.

Канал, созданный с помощью простого вызова make, называется небуферизованным каналом, но make принимает необязательный второй аргумент, целое значение, которое называется емкостью канала.  
Если емкость канала ненулевая, make создает буферизованный канал.

### 6. Что такое планировщик и как он работает?
Цель планировщика (scheduler) в том, чтобы распределять готовые к выполнению горутины (G) по свободным машинам (M)
Готовые к исполнению горутины выполняются в порядке очереди, то есть FIFO (First In, First Out).  
Исполнение горутины прерывается только тогда, когда она уже не может выполняться: то есть из-за системного вызова или использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.). Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась в очередь. Чтобы позволить планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched().
Как только функция вновь готова к выполнению, она снова попадает в очередь.    

Потоки операционной системы планируются в ее ядре. Каждые несколько миллисекунд аппаратный таймер прерывает процессор, что приводит к вызову функции ядра, именуемой планировщиком.  
Эта функция приостанавливает работу текущего потока и сохраняет значения его регистров в памяти, просматривает список потоков и решает, какой из них следует запустить следующим, восстанавливает регистры этого потока из памяти и возобновляет его выполнение.  
Так как потоки операционной системы планируются в ядре, передача управления от одного потока к другому требует полного переключения контекста, т.е. сохранения состояния одного пользовательского потока в памяти, восстановление состояния другого и обновление структур данных планировщика.   
Это медленная операция — из-за слабой локальности и необходимого количества обращений к памяти.  

Среда выполнения Go содержит собственный планировщик, который использует метод, известный как m:n-планирование, потому что он мультиплексирует (или планирует) выполнение m go-подпрограмм на n потоках операционной системы.  
Задания планировщика Go аналогичны заданиям планировщика ядра, но связаны только с go-подпрограммами одной программы Go.  

В отличие от планировщика потоков операционной системы планировщик Go вызывается не периодически аппаратным таймером, а неявно некоторыми конструкциями языка Go.   
Например, когда go-подпрограмма вызывает time.Sleep или блокируется операцией канала или мьютекса, планировщик переводит ее в спящий режим и запускает другую go-подпрограмму до тех пор, пока не наступит время активировать первую.
Поскольку переключение контекста ядра не требуется, планирование go-подпрограмм намного дешевле, чем потоков.

### 8. Как задать направление канала?

Мы можем задать направление передачи сообщений в канале, сделав его только отправляющим или принимающим. Например:

```go
func f(c chan<- string)
```

и канал `c` будет только отправлять сообщение. Попытка получить сообщение из канала c вызовет ошибку компилирования. Также мы можем изменить функцию `f`:

```go
func f(c <-chan string)
```

Существуют и двунаправленные каналы, которые могут быть переданы в функцию, принимающую только принимающие или отправляющие каналы. Но только отправляющие или принимающие каналы не могут быть переданы в функцию, требующую двунаправленного канала!

### 9. Напишите собственную функцию Sleep, используя time.After

```go
func sleep(s int) {
  <- time.After(time.Second * time.Duration(s)):
}
```

### 10. Что такое буферизированный канал? Как создать такой канал с ёмкостью в 20 сообщений?

При инициализации канала можно использовать второй параметр:

```go
c := make(chan int, 1)
```

и мы получим буферизированный канал с ёмкостью __1__. Обычно каналы работают синхронно - каждая из сторон ждёт, когда другая сможет получить или передать сообщение. Но буферизованный канал работает асинхронно — получение или отправка сообщения не заставляют стороны останавливаться. Но канал теряет пропускную способность, когда он занят, в данном случае, если мы отправим в канал __1__ сообщение, то мы не сможем отправить туда ещё одно до тех пор, пока первое не будет получено.

###  11. Напишите программу, которая меняет местами два числа (x := 1; y := 2; swap(&x, &y) должно дать x=2 и y=1)

```go
func main()  {
	x := 1
	y := 2

	swap(&x, &y)

	fmt.Println(x, y)
}

func swap(x, y *int) {
	*x, *y = *y, *x
}
```

### 12. Какое будет значение у переменной x после выполнения программы?

```go
func square(x *float64) {
	*x = *x * *x
}

func main() {
	x := 1.5
	square(&x)

	fmt.Println(x)
}
```

<details>
  <summary>Ответ</summary>
  Ответ: 2.25
</details>

### 13. Какое значение примет выражение (true && false) || (false && true) || !(false && false)?

```go
fmt.Println((true && false) || (false && true) || !(false && false))
```

<details>
  <summary>Ответ</summary>
  Ответ: true
</details>

### 14. Что выведет следующая программа?

```go
package main

import "fmt"

func main() {
   i := 65
   fmt.Println(string(i))
}
``` 

**Варианты:**

1. A
2. 65
3. Ошибка компиляции
4. Нет правильного ответа
5. Я не знаю

<details>
  <summary>Ответ</summary>
  Ответ: А
</details>

### 15. Что выведет следующая программа?

```go
package main

import "fmt"

func main() {
   a := [5]int{1, 2, 3, 4, 5}
   t := a[3:4:4]
   fmt.Println(t[0])
}
``` 

**Варианты:**

1. 3
2. 4
3. Ошибка компиляции
4. Нет правильного ответа
5. Я не знаю

<details>
  <summary>Ответ</summary>
  Ответ: 4
</details>

### 16. Как работает Garbage Collection в Go?
Garbage Collection - это процесс освобождения места в памяти, которое больше не используется. В документации указано следующее:
```go
GC выполняется конкурентно (concurrent), одновременно с потоками мутатора (mutator), в точном соответствии с типом (этот принцип также известен как чувствительность к типу), допускается парааллельная выполнение нескольких потоков GC. Это конкурентная пометка и очистка (mark-sweep), при которой используется барьер записи (write barrier). При этом в процессе ничего не генерируется и не сжимается. Освобождение памяти выполняется на основе размера, выделенного для каждой программы Р, чтобы в общем случае минимизировать фрагментацию и избежать блокировок.
``` 
В основе работы GC Go лежит "трехцветный алгоритм". Официальное название "трехцветный алгоритм пометки и очистки". Использует барьер памяти. Главный принцип алгоритма трехцветной пометки и очистки состоит в разделении объектов, находящихся куче, на три набора, в соответствии с "цветом".  Условно разделяются на 3 цвета:
- черные объекты - гарантированно не имеют указателей на белые объекты;
- серые объекты - могут иметь указатели на белые объекты;
- белые объекты - на них могут ссылаться некоторые серые объекты и сами некоторые белые объекты могут ссылаться на некоторые черные.
  Краткий алгоритм:
1. Все объекты сначала белые;
2. Идет перебор "корневых" объектов, помечаются как серые. Корневые - это объекты к которым можно обращаться напрямую, например глобальные переменные, элементы в стеке и т.д.
3. Идет перебор серых объектов, проверяются ссылки на другие объекты и помечаются на черные объекты. Если есть ссылка на белый объект, то белый становится серым.
4. Продолжается до тех пор, пока не будут перебраны все серые объекты.
5. Оставшиеся после перебора белые объекты считаются недостижимыми и занимаемая ими область памяти может быть освобождена.
   Есть еще Мутатор - это приложение, работающее во время сборки мусора. Вызывает функцию барьера записи. Выполняется каждый раз, когда меняется указатель в куче. После изменения указателя объект считается достижимым и помечается как серый.

### 17. Что такое interface, как они работают в Go?
В Go имеется еще одна разновидность типов — тип интерфейса. Интерфейс является абстрактным типом.
```go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
// Где tab — это указатель на Interface Table или itable — структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса.
// data — указывает на фактическую переменную с конкретным (статическим) типом,
```
1. Интерфейсы помогают уменьшить дублирование, то есть количество шаблонного кода.
2. Они облегчают использование в модульных тестах заглушек вместо реальных объектов.
3. Будучи архитектурным инструментом, интерфейсы помогают отвязывать части вашей кодовой базы.

Теперь несколько слов про itable. Поскольку эта таблица будет уникальна для каждой пары интерфейс-статический тип, то просчитывать её на этапе компиляции (early binding) будет нерационально и неэффективно.  
Вместо этого, компилятор генерирует метаданные для каждого статического типа, в которых, помимо прочего, хранится список методов, реализованных для данного типа.  
Аналогично генерируются метаданные со списком методов для каждого интерфейса. Теперь, во время исполнения программы, runtime Go может вычислить itable на лету (late binding) для каждой конкретной пары. Этот itable кешируется, поэтому просчёт происходит только один раз.  
Теперь вспомним про так называемый пустой интерфейс (empty interface) — interface{}, которому удовлетворяет вообще любой тип. Поскольку у пустого интерфейса нет никаких методов, то и itable для него просчитывать и хранить не нужно — достаточно только метаинформации о статическом типе.  
Декларация типа (type assertion) представляет собой операцию, применяемую к значению-интерфейсу. Синтаксически она выглядит, как х.(Т), где х — выражение интерфейсного типа, а Т является типом, именуемым “декларируемым'’ (asserted). Декларация типа проверяет, что динамический тип его операнда х соответствует декларируемому типу.

### 18. Что такое slice, как устроены и чем отличаются от массивов?
Массив – это коллекция фиксированного размера. Хранится в виде последовательности из n блоков определенного типа.   
Эта память распределяется в момент, когда вы инициализируете переменную типа массив.  
Если присвоить значение массива другой переменной, то присваиваемое значение просто будет скопировано.  
Пример использования - пакет crypto/sha256, генерация хэша, тип [32]byte | UUID [16]byte.
Передаются в функции как копия.
Срез — это легковесная структура данных, которая предоставляет доступ к подпоследовательности элементов массива (или, возможно, ко всем элементам), известного как базовый массив.  
Срез состоит из трех компонентов: указателя, длины и емкости. Для проверки длинны использовать len, т.к. []int{} != nil.
Передаются в функции по ссылке.
### 19. Что такое len и capacity в slice Go?
`// todo`
### 20. Возможно ли предугадать, что GC отработает за константное время N?
`// todo`
### 21. Что будет, если создать канал и отправить туда запись, но у него нет читателей?
`// todo`
### 22. Что выведет код? Как можно повлиять на вывод?
```go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	runtime.GOMAXPROCS(1)
	done := false
	go func() {
		done = true
	}()
	for !done {
	}
	fmt.Println("finished")
}  
``` 
### 23. Какая есть проблема в коде? Как её можно решить?
```
var counter int
for i := 0; i < 1000; i++ {
    go func() {
        counter++
    }()
}
``` 
### 24. За сколько примерно выполнится приложение — за 3 секунды или за 6?
```go
package main

import (
	"time"
)

func worker() chan int {
	ch := make(chan int)
	go func() {
		time.Sleep(3 * time.Second)
		ch <- 42
	}()
	return ch
}

func main() {
	timeStart := time.Now()
	_, _ = <-worker(), <-worker()
	println(int(time.Since(timeStart).Seconds())) // что выведет - 3 или 6?
}
``` 
### 25. Что произойдёт при выполнении данного кода?
```go
package main

import (
	"fmt"
)

type Test struct {
	Name string
}

func main() {
	mapCampaigns := make(map[string]*Test)
	name := mapCampaigns[""].Name
	fmt.Println(name)
}
``` 
### 26. Какая из записей будет требовать дополнительных действий по инициализации и почему
```
var a []int64
var b map[int64]string
c := []int64{}
d := make(map[int64]string)
``` 
### 27. Что вы можете сказать о данном коде? Что произойдет при вызове данных методов?
```
----
package a
func A1() int {return b.B() + 3}
func A2() int {return 2}
----
package b
func B() int {return a.A2() * 2}  
----
``` 
