# Задачи для разминки
## Задачи на БД
**№1**  
Составить структуру таблиц и связей (спроектировать бд библиотеки, автор, книга, пользователь. Много авторов, книга на руках у одного пользователя)

**№2**  
Несколько выборок с группировками по этой созданной БД
-	Найдите книги (в т.ч названия), которые на руках у пользователя и написанные более чем 2 авторами
-	Топ 3 популярных авторов

**№3**  
Пояснить какой индекс будет создан и почему именно такой при использовании конкретного запроса  
Построить оптимальный индекс для `SELECT * FROM employee WHERE sex = 'm' AND salary > 300000 AND age = 20 ORDER BY created_at`

## Задачи на алгоритмы
Доп задачки для переноса - [тут](https://habr.com/ru/company/rebrainme/blog/540354/)
Еще задачки - [тут](https://tproger.ru/problems/sobesedovanie-na-poziciju-middle-javascript-razrabotchika-primery-zadach-i-neobhodimye-znanija/)

**№1**  
Написать функцию, которая возвращает массив заданной длины, с уникальными числами

**№2**  
Написать функцию, которая будет валидировать строку со скобочками (задачка на скобочки. Нужно определить валидно ли расставлены скобочки {}{[]}() – true , {)(} – false, (([(]))) – false)

**№3**  
Написать функцию, которая принимает число n и возвращает матрицу nxn, где заполняет её значениями спирально (справа налево, к центру)

**№4**  
Есть структура геолокаций Страна-Регион-Город. На вход подаётся два массива, которые могут содержать произвольное количество элементов(но не более 3х) или быть пустыми.  
Первый элемент, это то, что должно быть в итоге показано, а второй - то, что должно быть исключено из показа.
Нужно определить пересекаются ли элементы и вернуть те, что пересекаются, например:
- Россия-Краснодарский край-Краснодар и Россия-Краснодарский край = Пересекаются и нужно исключить весь Краснодарский край
- Россия-Краснодарский край и Россия-Краснодарский край-Краснодар = Пересекаются и нужно исключить только Краснодар
- Россия-Ростовская область и Россия-Краснодарский край-Краснодар = Не пересекаются и исключать ничего не нужно

**№5**  
Написать функцию, которая из массива создаёт массив массивов, где каждый вложенный массив имеет заданную пользователем длинну  
Например  
На входе `[]int{1,2,3,4,5,6,7,8}`  
На выходе `[][]int{{1,2,3},{4,5,6},{7,8}}`

**№6**  
Написать конструктор функции-замыкания, которая на вход принимает n int, а при каждом вызове возвращает (n + 1 * Количество вызовов)  
Например
```
iter:=iterator(10)
iter() // 11
iter() // 12
```  

**№7**  
Написать функцию, которая получает на вход массив int, а возвращает массив int, где каждый элемент равен перемноженному значению всех элементов массива, кроме текущего. Сложность должна быть меньше О(n^2), нельзя использовать деление.

## Задачи на понимание архитектуры
**№1**  
Есть два сервиса, сервис один сохраняет данные и отправляет их в медленный сервис два - как бы вы организовали работу двух этих сервисов с учётом того, что сервис два медленный и только получает данные  

## Популярные задачи на собеседованиях

### 1. На вход подаются два неупорядоченных слайса любой длины. Надо написать функцию, которая возвращает их пересечение

Можно решить сортировкой, за более долгое время, но без выделения дополнительной памяти.
А можно выделить дополнительную память и решить за линейное время.

Надо посчитать количество появлений элементов первого массива (лучше брать тот, что покороче) — используем для этого словарь.
Потом пройтись по второму массиву и вычитать из словаря те элементы, которые есть в нем.
По ходу добавляем в результат те элементы, у которых частота появлений больше нуля.

- [x] Советуем посетить [Математические операции над множествами](https://github.com/goavengers/go-datastructure#-point_right-%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0-sets)

```go
package main

import (
	"fmt"
)

// На вход подаются два неупорядоченных массива любой длины.
// Необходимо написать функцию, которая возвращает пересечение массивов
func intersection(a, b []int) []int {
	counter := make(map[int]int)
	var result []int

	for _, elem := range a {
		counter[elem]++
	}
	
	for _, elem := range b {
		if count, ok := counter[elem]; ok && count > 0 {
			counter[elem] -= 1	
			result = append(result, elem)
		}
	}
	return result
}

func main() {

	a := []int{23, 3, 1, 2}
	b := []int{6, 2, 4, 23}
	// [2, 23]
	fmt.Printf("%v\n", intersection(a, b))
	a = []int{1, 1, 1}
	b = []int{1, 1, 1, 1}
	// [1, 1, 1]
	fmt.Printf("%v\n", intersection(a, b))
}
```

### 2. Написать генератор случайных чисел

В принципе, легкая задача, на базовые знания по асинхронному взаимодействию в Go.
Для решения я бы использовал небуфферезированный канал. Будем асинхронно писать туда случайные числа и закроем его, когда закончим писать.

Плюс ее можно использовать в немного измененном виде в задаче на [слияние N каналов](#3).

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func randNumsGenerator(n int) <-chan int {
	r := rand.New(rand.NewSource(time.Now().UnixNano()))

	out := make(chan int)
	go func() {
		for i := 0; i < n; i++ {
			out <- r.Intn(n)
		}
		close(out)
	}()
	return out
}

func main() {
	for num := range randNumsGenerator(10) {
		fmt.Println(num)
	}
}
```

### 3. Слить N каналов в один

Даны n каналов типа chan int. Надо написать функцию, которая смерджит все данные из этих каналов в один и вернет его.

Мы хотим, чтобы результат работы функции выглядел примерно так:

```go
for num := range joinChannels(a, b, c) {
       fmt.Println(num)
}
```

Для этого напишем функцию, которая будет асинхронно читать из исходных каналов, которые ей передадут в качестве аргументов, и писать в результирующий канал, который вернется из функции.

- Создаем канал, куда будем сливать все данные.
  Он будет небуферезированный, потому что мы не знаем, сколько данных придет из каналов.
- Дальше асинхронно прочитаем из исходных каналов и закроем результирующий канал для мерджа, когда все чтение закончится.
- Чтобы дождаться конца чтения, просто обернем этот цикл по каналам в wait group.

```go
package main

import (
	"sync"
)

func joinChannels(chs ...<-chan int) <-chan int {
	mergedCh := make(chan int)

	go func() {
		wg := &sync.WaitGroup{}

		wg.Add(len(chs))

		for _, ch := range chs {
			go func(ch <-chan int, wg *sync.WaitGroup) {
				defer wg.Done()
				
				for id := range ch {
					mergedCh <- id
				}
			}(ch, wg)
		}

		wg.Wait()
		close(mergedCh)
	}()

	return mergedCh
}
```

```go
package main

import (
	"fmt"
)

func main() {

	a := make(chan int)
	b := make(chan int)
	c := make(chan int)

	go func() {
		for _, num := range []int{1, 2, 3} {
			a <- num
		}
		close(a)
	}()

	go func() {
		for _, num := range []int{20, 10, 30} {
			b <- num
		}
		close(b)
	}()

	go func() {
		for _, num := range []int{300, 200, 100} {
			c <- num
		}
		close(c)
	}()

	for num := range joinChannels(a, b, c) {
		fmt.Println(num)
	}
}
```

### 4. Сделать конвейер чисел

Даны два канала.
В первый пишутся числа.
Нужно, чтобы числа читались из первого по мере поступления,
что-то с ними происходило (допустим, возводились в квадрат) и результат записывался во второй канал.

Довольно частая задача, более подробно можно почитать [тут](https://blog.golang.org/pipelines).

Решается довольно прямолинейно — запускаем две горутины.
- В одной пишем в первый канал.
- Во второй читаем из первого канала и пишем во второй.

Главное — не забыть закрыть каналы, чтобы ничего нигде не заблокировалось.

```go
package main

import (
	"fmt"
)

func main() {
	naturals := make(chan int)
	squares := make(chan int)

	go func() {
		for x := 0; x <= 10; x++ {
			naturals <- x
		}
		
		close(naturals)
	}()

	go func() {
		for x := range naturals {
			squares <- x * x
		}
		
		close(squares)
	}()

	for x := range squares {
		fmt.Println(x)
	}
}
```

### 5. Написать WorkerPool с заданной функцией

Довольно распространенная задача, плюс подобные задачи встречаются на практике.

Нам нужно разбить процессы на несколько горутин — при этом не создавать новую горутину каждый раз,
а просто переиспользовать уже имеющиеся.
- Для этого создадим канал с джобами и результирующий канал.
- Для каждого воркера создадим горутину, который будет ждать новую джобу, применять к ней заданную функцию и пулять ответ в результирующий канал.

```go
package main

import (
	"fmt"
)

func worker(id int, f func(int) int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        results <- f(j)
    }
}

func main() {

    const numJobs = 5
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)

    multiplier := func(x int) int {
	    return x * 10
    }

    for w := 1; w <= 3; w++ {
        go worker(w,  multiplier, jobs, results)
    }

    for j := 1; j <= numJobs; j++ {
        jobs <- j
    }
    
    close(jobs)

    for i := 1; i <= numJobs; i++ {
        fmt.Println(<-results)
    }
}
```

### 6. Сделать кастомную waitGroup на семафоре

Семафор можно легко получить из канала.
Чтоб не аллоцировать лишние данные, будем складывать туда пустые структуры.

В нашем случае мы хотим сделать семафор, который будет ждать выполнения пяти горутин.
- Для этого просто добавим вместо обычного канала буфферизированный.
- И внутри каждой горутины положим в него значение.
- А в конце будем дожидаться, что все ок — мы вычитаем все значения из канала.

```go
package main

import (
	"fmt"
)

type sema chan struct{}

func New(n int) sema {
	return make(sema, n)
}

func (s sema) Inc(k int) {
	for i := 0; i < k; i++ {
		s <- struct{}{}
	}
}

func (s sema) Dec(k int) {
	for i := 0; i < k; i++ {
		<-s
	}
}

func main() {
	numbers := []int{1, 2, 3, 4, 5}
	n := len(numbers)

	sem := New(n)

	for _, num := range numbers {
		go func(n int) {
			fmt.Println(n)
			sem.Inc(1)
		}(num)
	}

	sem.Dec(n)

}
```