# Базы данных
Немного о [разнице SQL и NOSQL решений](https://tproger.ru/translations/sql-nosql-database-models/)

## Базовое
### SQL
- SQLite: очень мощная встраиваемая РСУБД
- MySQL: самая популярная и часто используемая РСУБД
- PostgreSQL: самая продвинутая и гибкая РСУБД
- Oracle: мощная и гибкая СУБД, но с высокой стоимостью лицензии

### NOSQL
- MongoDB – хранит данные в формате, похожем на JSON(Документ)
- ClickHouse – напоминает классические реляционки, колоночная СУБД
- Aerospike – хранит данные в формате «Ключ-значение»

## Основные отличия
1. Структура и тип хранящихся данных – SQL/реляционные базы данных требуют наличия однозначно определённой структуры 
хранения данных, а NoSQL базы данных таких ограничений не ставят
2. Запросы – вне зависимости от лицензии, РСУБД реализуют SQL-стандарты, поэтому из них можно получать данные при помощи 
языка SQL. Каждая NoSQL база данных реализует свой способ работы с данными
3. Масштабируемость – оба решения легко растягиваются вертикально (например, путём увеличения системных ресурсов). 
Тем не менее, из-за своей современности, решения NoSQL обычно предоставляют более простые способы горизонтального 
масштабирования (например, создания кластера из нескольких машин)
4. Надёжность – когда речь заходит о надёжности, SQL базы данных однозначно впереди
5. Поддержка – РСУБД имеют очень долгую историю. Они очень популярны, и поэтому получить поддержку, платную или нет, 
очень легко. Поэтому, при необходимости, решить проблемы с ними гораздо проще, чем с NoSQL, особенно если проблема 
сложна по своей природе (например, при работе с MongoDB)
6. Хранение и доступ к сложным структурам данных – по своей природе реляционные базы данных предполагают работу с 
сложными ситуациями, поэтому и здесь они превосходят NoSQL-решения

## Индексы  
[Обзор](https://habr.com/ru/post/102785) типов индексов в разных РСУБД
#### B – деревья
- Хороши для данных с высокой кардинальностью
- Хороши для баз данных [OLTP](https://ru.wikipedia.org/wiki/OLTP)
- Занимают много места
- Легко обновляются
#### Битовые индексы
- Хороши для данных с низкой кардинальностью
- Хороши для приложений хранилищ данных [OLAP](https://ru.wikipedia.org/wiki/OLAP)
- Небольшие по размеру
- Долгий процесс обновления
#### HASH индексы
- Сравнивается не значение, а его хэш
- Нельзя сортировать по значению, что приводит к невозможности использования в сравнениях больше/меньше и «is null»
- Не уникален, для совпадающих хэшей применяются методы разрешения коллизий

### Индексы в Postgres
[Обзор](https://postgrespro.ru/docs/postgresql/9.6/indexes-types#:~:text=PostgreSQL%20%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%B2%D0%B0%D0%B5%D1%82%20%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2,%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BD%D0%B0%20%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B8%D0%BF%D1%8B%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2.) типов индексов в PostgresSQL
#### B – деревья
B-деревья могут работать в условиях на равенство и в проверках диапазонов с данными, которые можно отсортировать в 
некотором порядке. Точнее, планировщик запросов PostgreSQL может задействовать индекс-B-дерево, когда индексируемый 
столбец участвует в сравнении с одним из следующих операторов: **<, <=, =, >=, >**

#### HASH индексы
Хеш-индексы работают только с простыми условиями равенства. Планировщик запросов может применить хеш-индекс, только 
если индексируемый столбец участвует в сравнении с оператором =.

#### GiST индексы
представляют собой не просто разновидность индексов, а инфраструктуру, позволяющую реализовать много разных стратегий 
индексирования. Как следствие, GiST-индексы могут применяться с разными операторами, в зависимости от стратегии 
индексирования (класса операторов). Например, стандартный дистрибутив PostgreSQL включает классы операторов GiST
для нескольких двумерных типов геометрических данных, что позволяет применять индексы в запросах с операторами:
**<<,&<,&>,>>,<<|,&<|,|&>,|>>,@>,<@,~=,&&**

#### GIN индексы
представляют собой «инвертированные индексы», в которых могут содержаться значения с несколькими ключами, например 
массивы. Инвертированный индекс содержит отдельный элемент для значения каждого компонента, и может эффективно 
работать в запросах, проверяющих присутствие определённых значений компонентов.  
Операторы: <@,@>,=,&&

#### BRIN индексы
хранят обобщённые сведения о значениях, находящихся в физически последовательно расположенных блоках таблицы. 
Подобно GiST, SP-GiST и GIN, индексы BRIN могут поддерживать определённые пользователем стратегии, и в зависимости 
от них применяться с разными операторами. Для типов данных, имеющих линейный порядок сортировки, записям в индексе
соответствуют минимальные и максимальные значения данных в столбце для каждой зоны блоков. Это позволяет поддерживать 
запросы со следующими операторами:  **<, <=, =, >=, >**

## Основные понятия
### Транзакция
[Ссылка на wiki](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))  
Группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными

### Кардинальность
[Ссылка на wiki](https://ru.m.wikipedia.org/wiki/%D0%9C%D0%BE%D1%89%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0)  
Уникальность данных. Высокая кардинальность - уникальные данные, низкая кардинальность - повторяющиеся данные

### ACID
[Ссылка на wiki](https://ru.wikipedia.org/wiki/ACID)  
Требования к информационной системе

#### Atomicity
[Ссылка на wiki](https://ru.wikipedia.org/wiki/%D0%90%D1%82%D0%BE%D0%BC%D0%B0%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C) — 
Атомарность, гарантирует, что никакая транзакция не будет зафиксирована в системе частично

#### Consistency
[Ссылка на wiki](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85) — 
Согласованность. Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) 
и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных

#### Isolation 
Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат

##### Уровни изоляции 
###### Read uncommitted
Уровень, имеющий самую плохую согласованность данных, но самую высокую скорость выполнения транзакций. Название уровня 
говорит само за себя — каждая транзакция видит незафиксированные изменения другой транзакции (феномен грязного чтения). 
Посмотрим какое влияние оказывают друг на друга такие транзакции

###### Read committed
Для этого уровня параллельно исполняющиеся транзакции видят только зафиксированные изменения из других транзакций. Таким 
образом, данный уровень обеспечивает защиту от грязного чтения.

###### Repeatable read
Уровень, позволяющий предотвратить феномен неповторяющегося чтения. Т.е. мы не видим в исполняющейся транзакции 
измененные и удаленные записи другой транзакцией. Но все еще видим вставленные записи из другой транзакции. Чтение 
фантомов никуда не уходит.

###### Serializable
Уровень, при котором транзакции ведут себя как будто ничего более не существует, никакого влияния друг на друга нет. 
В классическом представлении этот уровень избавляет от эффекта чтения фантомов.

#### Durability
Стойкость. Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в 
оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения 
системы в работу

### CAP
[Ссылка на wiki](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP) - утверждение о том, что в
любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств

### Пессимистичные и оптимистичные блокировки
#### Оптимистичные
При оптимистичной блокировке на базе данных реальной блокировки не происходит. Вместо этого используется следующий
подход - если во время выполнения транзакции она изменяет данные, которые были изменены после её начала, то транзакция
прерывается с исключением. Использование оптимистичных блокировок позволяет избежать взаимных блокировок (dead-lock).
Для реализации оптимистичной блокировки часто используется версионирование данных - в таблицу добавляется колонка,
которая хранит текущую версию. При выполнении update в запросе в секции where передается версия данных, которая была
забрана на изменение. Если update вернул 0 изменённых строк, значит данные были уже изменены и транзакцию необходимо
запускать заново. Вместо версии можно хранить время последнего изменения данных.

#### Пессимистичные
При пессимистичной блокировке для записи ставится эксклюзивная блокировка на уровне базы данных, запрещая таким образом
доступ к данным из других транзакций. Существует несколько видов пессимистичных блокировок:

- блокировка при чтении
- блокировка при записи

При блокировке при чтении запись блокируется когда она запрашивается из базы данных. Недостаток метода в том, что таким
образом можно заблокировать даже те данные, которые не изменяются в рамках текущей транзакции.

При блокировке при записи блокировка даных происходит при их обновлении в базе данных до конца текущей транзакции.

Блокировка с данных снимается либо при коммите, либо при откате транзакции.

#### Сравнение
При разработке программного обеспечения необходимо выбирать стратегию блокировок данных. При этом следует учитывать
следующее:
- Если ситуация обновления одних и тех же данных в один момент времени относительно редка, то выгоднее использовать
  оптимистичную блокировку. В этом случае не будут происходить дорогая операция блокировки ресурсов.
- Если же возможность возникновения ситуации обновления одних и тех же данных достаточно высока, то лучше использовать
  пессимистичную блокировку, это снизит количество прерванных транзакций.
- Также следует учитывать, что при оптимистичной блокировке в случае прерывания транзакции её нужно запускать заново.

## Паттерны
### Шардирование
[Ссылка на wiki](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)) - 
подход, предполагающий разделение баз данных, отдельных её объектов или индексов поисковых систем на независимые 
сегменты, каждый из которых управляется отдельным экземпляром сервера базы данных, размещаемым, как правило, на 
отдельном вычислительном узле.

### Репликация
[Ссылка на wiki](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F_(%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D0%BA%D0%B0)) -
механизм синхронизации содержимого нескольких копий объекта (например, содержимого базы данных). Репликация — это 
процесс, под которым понимается копирование данных из одного источника на другой (или на множество других) и наоборот.

### Партиционирование
```TODO```