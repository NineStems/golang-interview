## Порождающие
### Фабричный метод (Factory Method)
Определяет общий интерфейс для создания объектов в
суперклассе, позволяя подклассам изменять тип создаваемых объектов.
#### Реализация
1. Приведите все создаваемые продукты к общему интерфейсу.
2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий 
интерфейс продукта.
3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки вызовами 
фабричного метода, перенося в него код создания различных продуктов.
4. В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов нужно создать.
5. На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём будет жить большой условный оператор, 
выбирающий класс создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.
6. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания 
соответствующего продукта из суперкласса.
   Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении 
параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.  
   Например, у вас есть класс Почта с подклассами АвиаПочта и НаземнаяПочта, а также классы продуктов Самолёт, 
Грузовик и Поезд. Авиа соответствует Самолётам, но для НаземнойПочты есть сразу два продукта. Вы могли бы создать
новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код может передавать в фабричный 
метод НаземнойПочты аргумент, контролирующий тип создаваемого продукта.
7. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то 
осталось — не беда, это будет его реализацией по умолчанию.
#### Применимость
- Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
- Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
- Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.
#### Плюсы
- Избавляет класс от привязки к конкретным классам продуктов.
- Выделяет код производства продуктов в одно место, упрощая поддержку кода.
- Упрощает добавление новых продуктов в программу.
- Реализует принцип открытости/закрытости.
#### Минусы
- Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать 
свой подкласс создателя.
#### [Пример](golang-examples/fabric/main.go)

### Абстрактная фабрика (Abstract Factory)
Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
#### Плюсы
- Гарантирует сочетаемость создаваемых продуктов.
- Избавляет клиентский код от привязки к конкретным классам продуктов.
- Выделяет код производства продуктов в одно место, упрощая поддержку кода.
- Упрощает добавление новых продуктов в программу.
- Реализует принцип открытости/закрытости.
#### Минусы
- Усложняет код программы из-за введения множества дополнительных классов.
- Требует наличия всех типов продуктов в каждой вариации.
#### Применимость
- Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от 
конкретных классов продуктов.
- Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.
#### Реализация
1. Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.
2. Сведите все вариации продуктов к общим интерфейсам.
3. Определите интерфейс абстрактной фабрики. Он должен иметь фабричные методы для создания каждого из типов продуктов.
4. Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, 
сколько и вариаций семейств продуктов.
5. Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.
6. Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

#### [Пример](golang-examples/abstract-fabric/main.go)

### Строитель (Builder)
Позволяет создавать сложные объекты пошагово.  
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
#### Плюсы
- Позволяет создавать продукты пошагово.
- Позволяет использовать один и тот же код для создания различных продуктов.
- Изолирует сложный код сборки продукта от его основной бизнес-логики.
#### Минусы
- Усложняет код программы из-за введения дополнительных классов. 
- Клиент будет привязан к конкретным классам строителей, так как в интерфейсе директора может не быть метода получения 
результата.
#### Применимость
- Когда вы хотите избавиться от «телескопического конструктора».
- Когда ваш код должен создавать разные представления какого-то объекта. Например, деревянные и железобетонные дома.
- Когда вам нужно собирать сложные составные объекты, например, деревья Компоновщика.
#### Реализация
1. Убедитесь в том, что создание разных представлений объекта можно свести к общим шагам.
2. Опишите эти шаги в общем интерфейсе строителей.
3. Для каждого из представлений объекта-продукта создайте по одному классу-строителю и реализуйте их 
методы строительства.
4. Не забудьте про метод получения результата. Обычно конкретные строители определяют собственные методы получения 
результата строительства. Вы не можете описать эти методы в интерфейсе строителей, поскольку продукты не обязательно 
должны иметь общий базовый класс или интерфейс. Но вы всегда сможете добавить метод получения результата в 
общий интерфейс, если ваши строители производят однородные продукты с общим предком.
5. Подумайте о создании класса директора. Его методы будут создавать различные конфигурации продуктов, вызывая 
разные шаги одного и того же строителя.
6. Клиентский код должен будет создавать и объекты строителей, и объект директора. Перед началом строительства 
клиент должен связать определённого строителя с директором. Это можно сделать либо через конструктор, либо через 
сеттер, либо подав строителя напрямую в строительный метод директора.
7. Результат строительства можно вернуть из директора, но только если метод возврата продукта удалось поместить 
в общий интерфейс строителей. Иначе вы жёстко привяжете директора к конкретным классам строителей
#### [Пример](golang-examples/builder/main.go)

### Прототип (Prototype)
Позволяет копировать объекты, не вдаваясь в подробности их реализации.
#### Плюсы
-  Позволяет клонировать объекты, не привязываясь к их конкретным классам.
-  Меньше повторяющегося кода инициализации объектов.
-  Ускоряет создание объектов.
-  Альтернатива созданию подклассов для конструирования сложных объектов.
#### Минусы
- Сложно клонировать составные объекты, имеющие ссылки на другие объекты.
#### Применимость
- Когда ваш код не должен зависеть от классов копируемых объектов.
- Когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то мог создать все эти классы, 
чтобы иметь возможность легко порождать объекты с определённой конфигурацией.
#### Реализация
1. Создайте интерфейс прототипов с единственным методом clone. Если у вас уже есть иерархия продуктов, метод 
клонирования можно объявить непосредственно в каждом из её классов.
2. Добавьте в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего 
класса. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего 
класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился о полях, объявленных в суперклассе.
3. Если ваш язык программирования не поддерживает перегрузку методов, то вам не удастся создать несколько версий 
конструктора. В этом случае копирование значений можно проводить и в другом методе, специально созданном для этих 
целей. Конструктор удобнее тем, что позволяет клонировать объект за один вызов.
4. Метод клонирования обычно состоит всего из одной строки: вызова оператора new с конструктором прототипа. 
Все классы, поддерживающие клонирование, должны явно определить метод clone, чтобы использовать собственный класс 
с оператором new. В обратном случае результатом клонирования станет объект родительского класса.
5. Опционально, создайте центральное хранилище прототипов. В нём удобно хранить вариации объектов, возможно, даже 
одного класса, но по-разному настроенных.
6. Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов. 
Такой фабричный метод должен на основании входящих аргументов искать в хранилище прототипов подходящий экземпляр, 
а затем вызывать его метод клонирования и возвращать полученный объект.
7. Наконец, нужно избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода 
хранилища прототипов.
#### [Пример](golang-examples/prototype/main.go)

### Одиночка (Singleton)
Решает две проблемы, нарушая принцип единственной ответственности класса.

1. Гарантирует наличие единственного экземпляра класса. Чаще всего это полезно для доступа к какому-то общему ресурсу, 
например, базе данных.  
Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. В этом случае хотелось 
бы получить старый объект, вместо создания нового.  
Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает 
новый объект.  
Глобальный доступ к одному объекту.  
Клиенты могут не подозревать, что работают с одним и тем же объектом.

2. Предоставляет глобальную точку доступа. Это не просто глобальная переменная, через которую можно достучаться к 
определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без
вашего ведома.  
Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, который решает проблему №1, а также иметь к нему 
простой и доступный интерфейс.  
Интересно, что в наше время паттерн стал настолько известен, что теперь люди называют «одиночками» даже те классы, 
которые решают лишь одну из проблем, перечисленных выше.
#### Плюсы
- Гарантирует наличие единственного экземпляра класса.
- Предоставляет к нему глобальную точку доступа.
- Реализует отложенную инициализацию объекта-одиночки.
#### Минусы
- Нарушает принцип единственной ответственности класса.
- Маскирует плохой дизайн.
- Проблемы мультипоточности.
- Требует постоянного создания Mock-объектов при юнит-тестировании.
#### Применимость
-  Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий 
доступ к базе данных из разных частей программы).
- Когда вам хочется иметь больше контроля над глобальными переменными.
#### Реализация
1. Добавьте в класс приватное статическое поле, которое будет содержать одиночный объект.
2. Объявите статический создающий метод, который будет использоваться для получения одиночки.
3. Добавьте «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод одиночки.
4. Сделайте конструктор класса приватным.

В клиентском коде замените вызовы конструктора одиночка вызовами его создающего метода.
#### [Пример](golang-examples/singleton/main.go)