## Структурные
### Адаптер
Позволяет объектам с несовместимыми интерфейсами работать вместе.
#### Плюсы
 - Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.
#### Минусы
- Усложняет код программы из-за введения дополнительных классов.
#### Применимость
- Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.
- Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, 
причём расширить суперкласс вы не можете.
#### Реализация
1. Убедитесь, что у вас есть два класса с несовместимыми интерфейсами
2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.
3. Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса.  
Обычно это поле заполняют объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект можно 
передавать через параметры методов адаптера.
4. Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису.
5. Приложение должно использовать адаптер только через клиентский интерфейс.  
Это позволит легко изменять и добавлять адаптеры в будущем.
#### [Пример](golang-examples/adapter/main.go)

### Мост
Разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя 
изменять их независимо друг от друга.
#### Плюсы
- Позволяет строить платформо-независимые программы.
- Скрывает лишние или опасные детали реализации от клиентского кода.
- Реализует принцип открытости/закрытости.
#### Минусы
- Усложняет код программы из-за введения дополнительных классов.
#### Применимость
- Когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности 
(например, если класс может работать с разными системами баз данных).
- Когда класс нужно расширять в двух независимых плоскостях.
- Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы.
#### Реализация
#### [Пример](golang-examples/bridge/main.go)
1. Определите, существует ли в ваших классах два непересекающихся измерения. Это может быть функциональность/платформа,
предметная-область/инфраструктура, фронт-энд/бэк-энд или интерфейс/реализация.
2. Продумайте, какие операции будут нужны клиентам, и опишите их в базовом классе абстракции.
3. Определите поведения, доступные на всех платформах, и выделите из них ту часть, которая нужна абстракции. 
На основании этого опишите общий интерфейс реализации.
4. Для каждой платформы создайте свой класс конкретной реализации. Все они должны следовать общему интерфейсу, 
который мы выделили перед этим.
5. Добавьте в класс абстракции ссылку на объект реализации. Реализуйте методы абстракции, делегируя основную работу 
связанному объекту реализации.
6. Если у вас есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.
7. Клиент должен подать объект реализации в конструктор абстракции, чтобы связать их воедино. После этого он может 
свободно использовать объект абстракции, забыв о реализации.

### Компоновщик
Позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это 
единичный объект.
#### Плюсы
- Упрощает архитектуру клиента при работе со сложным деревом компонентов.
- Облегчает добавление новых видов компонентов.
#### Минусы
- Создаёт слишком общий дизайн классов.
#### Применимость
- Когда вам нужно представить древовидную структуру объектов.
- Когда клиенты должны единообразно трактовать простые и составные объекты.
#### Реализация
1. Убедитесь, что вашу бизнес-логику можно представить как древовидную структуру. Попытайтесь разбить её на простые 
компоненты и контейнеры. Помните, что контейнеры могут содержать как простые компоненты, так и другие вложенные контейнеры.
2. Создайте общий интерфейс компонентов, который объединит операции контейнеров и простых компонентов дерева. 
Интерфейс будет удачным, если вы сможете использовать его, чтобы взаимозаменять простые и составные компоненты без 
потери смысла.
3. Создайте класс компонентов-листьев, не имеющих дальнейших ответвлений. Имейте в виду, что программа может 
содержать несколько таких классов.
4. Создайте класс компонентов-контейнеров и добавьте в него массив для хранения ссылок на вложенные компоненты. 
Этот массив должен быть способен содержать как простые, так и составные компоненты, поэтому убедитесь, что он объявлен 
с типом интерфейса компонентов.  
Реализуйте в контейнере методы интерфейса компонентов, помня о том, что контейнеры должны делегировать основную работу 
своим дочерним компонентам.
5. Добавьте операции добавления и удаления дочерних компонентов в класс контейнеров.  
Имейте в виду, что методы добавления/удаления дочерних компонентов можно поместить и в интерфейс компонентов. Да, 
это нарушит принцип разделения интерфейса, так как реализации методов будут пустыми в компонентах-листьях. 
Но зато все компоненты дерева станут действительно одинаковыми для клиента.

#### [Пример](golang-examples/composite/main.go)

### Декоратор
Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».
#### Плюсы
- Большая гибкость, чем у наследования.
- Позволяет добавлять обязанности на лету.
- Можно добавлять несколько новых обязанностей сразу.
- Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.
#### Минусы
- Трудно конфигурировать многократно обёрнутые объекты.
- Обилие крошечных классов.
#### Применимость
-  Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.
- Когда нельзя расширить обязанности объекта с помощью наследования.
#### Реализация
1. Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.
2. Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений.
3. Создайте класс конкретного компонента и поместите в него основную бизнес-логику.
4. Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. 
Все методы базового декоратора должны делегировать действие вложенному объекту.
5. И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.
6. Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен 
выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта.
7. Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.
#### [Пример](golang-examples/decorator/main.go)

### Фасад
Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.
#### Плюсы
- Изолирует клиентов от компонентов сложной подсистемы.
- Фасад рискует стать божественным объектом, привязанным ко всем классам программы.
#### Минусы
#### Применимость
- Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.
- Когда вы хотите разложить подсистему на отдельные слои.
#### Реализация
1. Определите, можно ли создать более простой интерфейс, чем тот, который предоставляет сложная подсистема. 
Вы на правильном пути, если этот интерфейс избавит клиента от необходимости знать о подробностях подсистемы.
2. Создайте класс фасада, реализующий этот интерфейс. Он должен переадресовывать вызовы клиента нужным объектам 
подсистемы. Фасад должен будет позаботиться о том, чтобы правильно инициализировать объекты подсистемы.
3. Вы получите максимум пользы, если клиент будет работать только с фасадом. В этом случае изменения в подсистеме 
будут затрагивать только код фасада, а клиентский код останется рабочим.
4. Если ответственность фасада начинает размываться, подумайте о введении дополнительных фасадов
#### [Пример](golang-examples/facade/main.go)

### Легковес
Позволяет вместить большее количество объектов в отведённую оперативную память.   
Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в 
каждом объекте.
#### Плюсы
- Экономит оперативную память.
#### Минусы
- Расходует процессорное время на поиск/вычисление контекста.
- Усложняет код программы из-за введения множества дополнительных классов.
#### Применимость
- Когда не хватает оперативной памяти для поддержки всех нужных объектов.
#### Реализация
1. Разделите поля класса, который станет легковесом, на две части:
   - внутреннее состояние: значения этих полей одинаковы для большого числа объектов;
   - внешнее состояние (контекст): значения полей уникальны для каждого объекта.
2. Оставьте поля внутреннего состояния в классе, но убедитесь, что их значения неизменяемы. Эти поля должны 
инициализироваться только через конструктор.
3. Превратите поля внешнего состояния в параметры методов, где эти поля использовались. Затем удалите поля из класса.
4. Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты. Клиент должен запрашивать 
из этой фабрики легковеса с определённым внутренним состоянием, а не создавать его напрямую.
5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в методы объекта 
легковеса.
#### [Пример](golang-examples/flyweight/main.go)

### Заместитель
Позволяет подставлять вместо реальных объектов специальные объекты-заменители.  
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.
#### Плюсы
- Позволяет контролировать сервисный объект незаметно для клиента.
- Может работать, даже если сервисный объект ещё не создан.
- Может контролировать жизненный цикл служебного объекта.
#### Минусы
- Усложняет код программы из-за введения дополнительных классов.
- Увеличивает время отклика от сервиса.
#### Применимость
- Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы 
или базы данных.
- Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей, и вам хочется защищать объект 
от неавторизованного доступа. Например, если ваши объекты — это важная часть операционной системы, 
а пользователи — сторонние программы (хорошие или вредоносные).
- Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.
- Логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту.
- Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов и управлять их жизненным 
циклом.
#### Реализация
1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.
2. Создайте класс заместителя. Он должен содержать ссылку на сервисный объект. Чаще всего, сервисный объект создаётся 
самим заместителем. В редких случаях заместитель получает готовый сервисный объект от клиента через конструктор.
3. Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то 
полезную работу, методы заместителя должны передать запрос сервисному объекту.
4. Подумайте о введении фабрики, которая решала бы, какой из объектов создавать — заместитель или реальный сервисный 
объект. Но, с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.
5. Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении клиента к методам 
заместителя.
#### [Пример](golang-examples/flyweight/main.go)