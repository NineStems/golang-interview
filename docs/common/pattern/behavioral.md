## Поведенческие

### Цепочка обязанностей
Позволяет передавать запросы последовательно по цепочке обработчиков.  
Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.
#### Плюсы
- Уменьшает зависимость между клиентом и обработчиками.
- Реализует принцип единственной обязанности.
- Реализует принцип открытости/закрытости.
#### Минусы
- Запрос может остаться никем не обработанным.
#### Применимость
- Когда программа должна обрабатывать разнообразные запросы несколькими способами, 
но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.
- Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.
- Когда набор объектов, способных обработать запрос, должен задаваться динамически.
#### Реализация
1. Создайте интерфейс обработчика и опишите в нём основной метод обработки.
Продумайте, в каком виде клиент должен передавать данные запроса в обработчик. 
Самый гибкий способ — превратить данные запроса в объект и передавать его целиком через параметры метода обработчика.
2. Имеет смысл создать абстрактный базовый класс обработчиков, чтобы не 
дублировать реализацию метода получения следующего обработчика во всех конкретных обработчиках.
Добавьте в базовый обработчик поле для хранения ссылки на следующий объект цепочки. 
Устанавливайте начальное значение этого поля через конструктор. Это сделает объекты обработчиков неизменяемыми. 
Но если программа предполагает динамическую перестройку цепочек, можете добавить и сеттер для поля.
Реализуйте базовый метод обработки так, чтобы он перенаправлял запрос следующему объекту, 
проверив его наличие. Это позволит полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы дальше по цепи, обращаясь к родительской реализации метода.
3. Один за другим создайте классы конкретных обработчиков и реализуйте в них методы обработки запросов. 
При получении запроса каждый обработчик должен решить:
   - Может ли он обработать запрос или нет?
   - Следует ли передать запрос следующему обработчику или нет?
4. Клиент может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику, 
либо получать уже готовые цепочки извне. В последнем случае цепочки собираются фабричными объектами, опираясь на конфигурацию приложения или параметры окружения.
5. Клиент может посылать запросы любому обработчику в цепи, а не только первому. 
Запрос будет передаваться по цепочке до тех пор, пока какой-то обработчик не откажется передавать его дальше, либо когда будет достигнут конец цепи.
6. Клиент должен знать о динамической природе цепочки и быть готов к таким случаям:
   - Цепочка может состоять из единственного объекта.
   - Запросы могут не достигать конца цепи.
   - Запросы могут достигать конца, оставаясь необработанными.
#### [Пример](golang-examples/chain/main.go)

### Команда
Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, 
логировать их, а также поддерживать отмену операций.
#### Плюсы
- Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
- Позволяет реализовать простую отмену и повтор операций.
- Позволяет реализовать отложенный запуск операций.
- Позволяет собирать сложные команды из простых.
- Реализует принцип открытости/закрытости.
#### Минусы
- Усложняет код программы из-за введения множества дополнительных классов.
#### Применимость
- Когда вы хотите параметризовать объекты выполняемым действием.
- Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.
- Когда вам нужна операция отмены.
#### Реализация
1. Создайте общий интерфейс команд и определите в нём метод запуска.
2. Один за другим создайте классы конкретных команд. В каждом классе должно быть поле для хранения ссылки на один или 
несколько объектов-получателей, которым команда будет перенаправлять основную работу.
Кроме этого, команда должна иметь поля для хранения параметров, которые нужны при вызове методов получателя. 
Значения всех этих полей команда должна получать через конструктор.
И, наконец, реализуйте основной метод команды, вызывая в нём те или иные методы получателя.
3. Добавьте в классы отправителей поля для хранения команд. Обычно объекты-отправители принимают готовые объекты команд 
извне — через конструктор либо через сеттер поля команды.
4. Измените основной код отправителей так, чтобы они делегировали выполнение действия команде.
5. Порядок инициализации объектов должен выглядеть так:
   - Создаём объекты получателей.
   - Создаём объекты команд, связав их с получателями.
   - Создаём объекты отправителей, связав их с командами.
#### [Пример](golang-examples/command/main.go)

### Итератор

#### Плюсы
#### Минусы
#### Применимость
#### Реализация
#### [Пример]()

### Посредник

#### Плюсы
#### Минусы
#### Применимость
#### Реализация
#### [Пример]()

### Снимок

#### Плюсы
#### Минусы
#### Применимость
#### Реализация
#### [Пример]()

### Наблюдатель

#### Плюсы
#### Минусы
#### Применимость
#### Реализация
#### [Пример]()

### Состояние

#### Плюсы
#### Минусы
#### Применимость
#### Реализация
#### [Пример]()

### Стратегия

#### Плюсы
#### Минусы
#### Применимость
#### Реализация
#### [Пример]()

### Шаблонный метод

#### Плюсы
#### Минусы
#### Применимость
#### Реализация
#### [Пример]()

### Посетитель

#### Плюсы
#### Минусы
#### Применимость
#### Реализация
#### [Пример]()
