## Поведенческие

### Цепочка обязанностей (Chain of Responsibility)
Позволяет передавать запросы последовательно по цепочке обработчиков.  
Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.
#### Плюсы
- Уменьшает зависимость между клиентом и обработчиками.
- Реализует принцип единственной обязанности.
- Реализует принцип открытости/закрытости.
#### Минусы
- Запрос может остаться никем не обработанным.
#### Применимость
- Когда программа должна обрабатывать разнообразные запросы несколькими способами, 
но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.
- Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.
- Когда набор объектов, способных обработать запрос, должен задаваться динамически.
#### Реализация
1. Создайте интерфейс обработчика и опишите в нём основной метод обработки.
Продумайте, в каком виде клиент должен передавать данные запроса в обработчик. 
Самый гибкий способ — превратить данные запроса в объект и передавать его целиком через параметры метода обработчика.
2. Имеет смысл создать абстрактный базовый класс обработчиков, чтобы не 
дублировать реализацию метода получения следующего обработчика во всех конкретных обработчиках.
Добавьте в базовый обработчик поле для хранения ссылки на следующий объект цепочки. 
Устанавливайте начальное значение этого поля через конструктор. Это сделает объекты обработчиков неизменяемыми. 
Но если программа предполагает динамическую перестройку цепочек, можете добавить и сеттер для поля.
Реализуйте базовый метод обработки так, чтобы он перенаправлял запрос следующему объекту, 
проверив его наличие. Это позволит полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы 
дальше по цепи, обращаясь к родительской реализации метода.
3. Один за другим создайте классы конкретных обработчиков и реализуйте в них методы обработки запросов. 
При получении запроса каждый обработчик должен решить:
   - Может ли он обработать запрос или нет?
   - Следует ли передать запрос следующему обработчику или нет?
4. Клиент может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику, 
либо получать уже готовые цепочки извне. В последнем случае цепочки собираются фабричными объектами, опираясь на 
конфигурацию приложения или параметры окружения.
5. Клиент может посылать запросы любому обработчику в цепи, а не только первому. 
Запрос будет передаваться по цепочке до тех пор, пока какой-то обработчик не откажется передавать его дальше, либо 
когда будет достигнут конец цепи.
6. Клиент должен знать о динамической природе цепочки и быть готов к таким случаям:
   - Цепочка может состоять из единственного объекта.
   - Запросы могут не достигать конца цепи.
   - Запросы могут достигать конца, оставаясь необработанными.
#### [Пример](golang-examples/chain/main.go)

### Команда (Action,Command)
Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, 
логировать их, а также поддерживать отмену операций.
#### Плюсы
- Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
- Позволяет реализовать простую отмену и повтор операций.
- Позволяет реализовать отложенный запуск операций.
- Позволяет собирать сложные команды из простых.
- Реализует принцип открытости/закрытости.
#### Минусы
- Усложняет код программы из-за введения множества дополнительных классов.
#### Применимость
- Когда вы хотите параметризовать объекты выполняемым действием.
- Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.
- Когда вам нужна операция отмены.
#### Реализация
1. Создайте общий интерфейс команд и определите в нём метод запуска.
2. Один за другим создайте классы конкретных команд. В каждом классе должно быть поле для хранения ссылки на один или 
несколько объектов-получателей, которым команда будет перенаправлять основную работу.
Кроме этого, команда должна иметь поля для хранения параметров, которые нужны при вызове методов получателя. 
Значения всех этих полей команда должна получать через конструктор.
И, наконец, реализуйте основной метод команды, вызывая в нём те или иные методы получателя.
3. Добавьте в классы отправителей поля для хранения команд. Обычно объекты-отправители принимают готовые объекты команд 
извне — через конструктор либо через сеттер поля команды.
4. Измените основной код отправителей так, чтобы они делегировали выполнение действия команде.
5. Порядок инициализации объектов должен выглядеть так:
   - Создаём объекты получателей.
   - Создаём объекты команд, связав их с получателями.
   - Создаём объекты отправителей, связав их с командами.
#### [Пример](golang-examples/command/main.go)

### Итератор (Iterator)
Даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.
#### Плюсы
- Упрощает классы хранения данных.
- Позволяет реализовать различные способы обхода структуры данных.
- Позволяет одновременно перемещаться по структуре данных в разные стороны.
#### Минусы
- Не оправдан, если можно обойтись простым циклом.
#### Применимость
- Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации 
(из-за сложности или вопросов безопасности).
- Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.
- Когда вам хочется иметь единый интерфейс обхода различных структур данных.
#### Реализация
1. Создайте общий интерфейс итераторов. Обязательный минимум — это операция получения следующего элемента коллекции. 
Но для удобства можно предусмотреть и другое. Например, методы для получения предыдущего элемента, текущей позиции, 
проверки окончания обхода и прочие.
2. Создайте интерфейс коллекции и опишите в нём метод получения итератора. Важно, чтобы сигнатура метода возвращала 
общий интерфейс итераторов, а не один из конкретных итераторов.
3. Создайте классы конкретных итераторов для тех коллекций, которые нужно обходить с помощью паттерна. Итератор должен 
быть привязан только к одному объекту коллекции. Обычно эта связь устанавливается через конструктор.
4. Реализуйте методы получения итератора в конкретных классах коллекций. Они должны создавать новый итератор того 
класса, который способен работать с данным типом коллекции. Коллекция должна передавать ссылку на собственный объект 
в конструктор итератора.
5. В клиентском коде и в классах коллекций не должно остаться кода обхода элементов. Клиент должен получать новый 
итератор из объекта коллекции каждый раз, когда ему нужно перебрать её элементы.
#### [Пример](golang-examples/iterator/main.go)

### Посредник (Controller,Mediator)
Позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.
#### Плюсы
- Устраняет зависимости между компонентами, позволяя повторно их использовать.
- Упрощает взаимодействие между компонентами.
- Централизует управление в одном месте
#### Минусы
- Посредник может сильно раздуться.
#### Применимость
-  Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами.
-  Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов.
- Когда вам приходится создавать множество подклассов компонентов, чтобы использовать одни и те же компоненты в
разных контекстах.
#### Реализация
1. Найдите группу тесно переплетённых классов, отвязав которые друг от друга, можно получить некоторую пользу. Например,
чтобы повторно использовать их код в другой программе.
2. Создайте общий интерфейс посредников и опишите в нём методы для взаимодействия с компонентами. В простейшем случае 
достаточно одного метода для получения оповещений от компонентов.
Этот интерфейс необходим, если вы хотите повторно использовать классы компонентов для других задач. В этом случае всё, 
что нужно сделать — это создать новый класс конкретного посредника.
3. Реализуйте этот интерфейс в классе конкретного посредника. Поместите в него поля, которые будут содержать ссылки на 
все объекты компонентов.
4. Вы можете пойти дальше и переместить код создания компонентов в класс посредника, после чего он может напоминать 
фабрику или фасад.
5. Компоненты тоже должны иметь ссылку на объект посредника. Связь между ними удобнее всего установить, подавая 
посредника в параметры конструктора компонентов.
6. Измените код компонентов так, чтобы они вызывали метод оповещения посредника, вместо методов других компонентов. 
С противоположной стороны, посредник должен вызывать методы нужного компонента, когда получает оповещение от компонента.
#### [Пример](golang-examples/mediator/main.go)

### Снимок (Memento)
Позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.
#### Плюсы
- Не нарушает инкапсуляции исходного объекта.
- Упрощает структуру исходного объекта. Ему не нужно хранить историю версий своего состояния.
#### Минусы
- Требует много памяти, если клиенты слишком часто создают снимки.
- Может повлечь дополнительные издержки памяти, если объекты, хранящие историю, не освобождают ресурсы, занятые 
устаревшими снимками.
- В некоторых языках (например, PHP, Python, JavaScript) сложно гарантировать, чтобы только исходный объект имел 
доступ к состоянию снимка
#### Применимость
- Когда вам нужно сохранять мгновенные снимки состояния объекта (или его части), чтобы впоследствии объект можно было 
восстановить в том же состоянии.
- Когда прямое получение состояния объекта раскрывает приватные детали его реализации, нарушая инкапсуляцию.
#### Реализация
1. Определите класс создателя, объекты которого должны создавать снимки своего состояния.
2. Создайте класс снимка и опишите в нём все те же поля, которые имеются в оригинальном классе-создателе.
3. Сделайте объекты снимков неизменяемыми. Они должны получать начальные значения только один раз, 
через свой конструктор.
4. Если ваш язык программирования это позволяет, сделайте класс снимка вложенным в класс создателя. Если нет, 
извлеките из класса снимка пустой интерфейс, который будет доступен остальным объектам программы. Впоследствии вы 
можете добавить в этот интерфейс некоторые вспомогательные методы, дающие доступ к метаданным снимка, однако прямой 
доступ к данным создателя должен быть исключён.
5. Добавьте в класс создателя метод получения снимков. Создатель должен создавать новые объекты снимков, передавая 
значения своих полей через конструктор.
Сигнатура метода должна возвращать снимки через ограниченный интерфейс, если он у вас есть. Сам класс должен 
работать с конкретным классом снимка.
6. Добавьте в класс создателя метод восстановления из снимка. Что касается привязки к типам, руководствуйтесь той же 
логикой, что и в пункте 4.
7. Опекуны, будь то история операций, объекты команд или нечто иное, должны знать о том, когда запрашивать снимки у 
создателя, где их хранить и когда восстанавливать.
8. Связь опекунов с создателями можно перенести внутрь снимков. В этом случае каждый снимок будет привязан к своему 
создателю и должен будет сам восстанавливать его состояние. Но это будет работать либо если классы снимков вложены в 
классы создателей, либо если создатели имеют соответствующие сеттеры для установки значений своих полей.
#### [Пример](golang-examples/snapshot/main.go)

### Наблюдатель (Observer)
Создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.
#### Плюсы
- Издатели не зависят от конкретных классов подписчиков и наоборот.
- Вы можете подписывать и отписывать получателей на лету.
- Реализует принцип открытости/закрытости.
#### Минусы
- Подписчики оповещаются в случайном порядке.
#### Применимость
- Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие 
именно объекты должны отреагировать.
- Когда одни объекты должны наблюдать за другими, но только в определённых случаях.
#### Реализация
1. Разбейте вашу функциональность на две части: независимое ядро и опциональные зависимые части. Независимое ядро станет
издателем. Зависимые части станут подписчиками.
2. Создайте интерфейс подписчиков. Обычно в нём достаточно определить единственный метод оповещения.
3. Создайте интерфейс издателей и опишите в нём операции управления подпиской. Помните, что издатель должен работать 
только с общим интерфейсом подписчиков.
4. Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей. 
Самый очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться 
все издатели.
Но если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно. 
В этом случае вы можете поместить логику подписки во вспомогательный объект и делегировать ему работу из издателей.
5. Создайте классы конкретных издателей. Реализуйте их так, чтобы после каждого изменения состояния они отправляли 
оповещения всем своим подписчикам.
6. Реализуйте метод оповещения в конкретных подписчиках. Не забудьте предусмотреть параметры, через которые издатель 
мог бы отправлять какие-то данные, связанные с происшедшим событием.
Возможен и другой вариант, когда подписчик, получив оповещение, сам возьмёт из объекта издателя нужные данные. 
Но в этом случае вы будете вынуждены привязать класс подписчика к конкретному классу издателя.
7. Клиент должен создавать необходимое количество объектов подписчиков и подписывать их у издателей.
#### [Пример](golang-examples/observer/main.go)

### Состояние (State)
Позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, 
что изменился класс объекта.
#### Плюсы
- Избавляет от множества больших условных операторов машины состояний.
- Концентрирует в одном месте код, связанный с определённым состоянием.
- Упрощает код контекста.
#### Минусы
- Может неоправданно усложнить код, если состояний мало и они редко меняются.
#### Применимость
- Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов
состояний много, и их код часто меняется.
- Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в 
зависимости от текущих значений полей класса.
- Когда вы сознательно используете табличную машину состояний, построенную на условных операторах, но вынуждены 
мириться с дублированием кода для похожих состояний и переходов.
#### Реализация
1. Определитесь с классом, который будет играть роль контекста. Это может быть как существующий класс, в котором уже 
есть зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.
2. Создайте общий интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных в контексте. 
Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.
3. Для каждого фактического состояния создайте класс, реализующий интерфейс состояния. Переместите код, связанный с 
конкретными состояниями в нужные классы. В конце концов, все методы интерфейса состояния должны быть реализованы во 
всех классах состояний.
При переносе поведения из контекста вы можете столкнуться с тем, что это поведение зависит от приватных полей или 
методов контекста, к которым нет доступа из объекта состояния. Существует парочка способов обойти эту проблему.
Самый простой — оставить поведение внутри контекста, вызывая его из объекта состояния. С другой стороны, вы можете 
сделать классы состояний вложенными в класс контекста, и тогда они получат доступ ко всем приватным частям контекста. 
Но последний способ доступен только в некоторых языках программирования (например, Java, C#).
4. Создайте в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения этого поля.
5. Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих 
методов объекта-состояния.
6. В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста, 
либо внутри классов конкретных состояний.
#### [Пример](golang-examples/state/main.go)

### Стратегия (Strategy)
Определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно 
взаимозаменять прямо во время исполнения программы.
#### Плюсы
- Горячая замена алгоритмов на лету.
- Изолирует код и данные алгоритмов от остальных классов.
- Уход от наследования к делегированию.
- Реализует принцип открытости/закрытости.
#### Минусы
- Усложняет программу за счёт дополнительных классов.
- Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.
#### Применимость
- Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.
- Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.
- Когда вы не хотите обнажать детали реализации алгоритмов для других классов.
- Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого 
оператора представляет собой вариацию алгоритма.
#### Реализация
1. Определите алгоритм, который подвержен частым изменениям. Также подойдёт алгоритм, имеющий несколько вариаций, 
которые выбираются во время выполнения программы.
2. Создайте интерфейс стратегий, описывающий этот алгоритм. Он должен быть общим для всех вариантов алгоритма.
3. Поместите вариации алгоритма в собственные классы, которые реализуют этот интерфейс.
4. В классе контекста создайте поле для хранения ссылки на текущий объект-стратегию, а также метод для её изменения. 
Убедитесь в том, что контекст работает с этим объектом только через общий интерфейс стратегий.
5. Клиенты контекста должны подавать в него соответствующий объект-стратегию, когда хотят, чтобы контекст вёл себя 
определённым образом.
#### [Пример](golang-examples/strategy/main.go)

### Шаблонный метод (Template Method)
Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет 
подклассам переопределять шаги алгоритма, не меняя его общей структуры.
#### Плюсы
- Облегчает повторное использование кода.
#### Минусы
- Вы жёстко ограничены скелетом существующего алгоритма.
- Вы можете нарушить принцип подстановки Барбары Лисков, 
изменяя базовое поведение одного из шагов алгоритма через подкласс.
- С ростом количества шагов шаблонный метод становится слишком сложно поддерживать.
#### Применимость
- Когда подклассы должны расширять базовый алгоритм, не меняя его структуры.
- Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. Если вы редактируете один 
класс, то приходится вносить такие же правки и в остальные классы.
#### Реализация
1. Изучите алгоритм и подумайте, можно ли его разбить на шаги. Прикиньте, какие шаги будут стандартными для всех
вариаций алгоритма, а какие — изменяющимися.
2. Создайте абстрактный базовый класс. Определите в нём шаблонный метод. Этот метод должен состоять из вызовов шагов 
алгоритма. Имеет смысл сделать шаблонный метод финальным, чтобы подклассы не могли переопределить его (если ваш язык 
программирования это позволяет).
3. Добавьте в абстрактный класс методы для каждого из шагов алгоритма. Вы можете сделать эти методы абстрактными или 
добавить какую-то реализацию по умолчанию. В первом случае все подклассы должны будут реализовать эти методы, а во 
втором — только если реализация шага в подклассе отличается от стандартной версии.
4. Подумайте о введении в алгоритм хуков. Чаще всего, хуки располагают между основными шагами алгоритма, а также до и
после всех шагов.
5. Создайте конкретные классы, унаследовав их от абстрактного класса. Реализуйте в них все недостающие шаги и хуки.
#### [Пример](golang-examples/template/main.go)

### Посетитель (Visitor)
Позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.
#### Плюсы
#### Минусы
#### Применимость
- Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.
- Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы 
не хотите «засорять» классы такими операциями.
- Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.
#### Реализация
1. Создайте интерфейс посетителя и объявите в нём методы «посещения» для каждого класса элемента, который существует 
в программе.
2. Опишите интерфейс элементов. Если вы работаете с уже существующими классами, то объявите абстрактный метод принятия 
посетителей в базовом классе иерархии элементов.
3. Реализуйте методы принятия во всех конкретных элементах. Они должны переадресовывать вызовы тому методу посетителя, 
в котором тип параметра совпадает с текущим классом элемента.
4. Иерархия элементов должна знать только о базовом интерфейсе посетителей. С другой стороны, посетители будут знать 
обо всех классах элементов.
5. Для каждого нового поведения создайте конкретный класс посетителя. Приспособьте это поведение для работы со всеми 
типами элементов, реализовав все методы интерфейса посетителей.
Вы можете столкнуться с ситуацией, когда посетителю нужен будет доступ к приватным полям элементов. В этом случае вы 
можете либо раскрыть доступ к этим полям, нарушив инкапсуляцию элементов, либо сделать класс посетителя вложенным в 
класс элемента, если вам повезло писать на языке, который поддерживает вложенность классов.
6. Клиент будет создавать объекты посетителей, а затем передавать их элементам, используя метод принятия.
#### [Пример](golang-examples/visitor/main.go)
