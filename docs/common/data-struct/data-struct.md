## Основные
### Массив
Хранит набор значений (элементов массива), идентифицируемых по индексу или набору индексов, принимающих целые 
(или приводимые к целым) значения из некоторого заданного непрерывного диапазона. Одномерный массив можно рассматривать 
как реализацию абстрактного типа данных — вектор. В некоторых языках программирования массив может называться также 
таблица, ряд, вектор, матрица.  

Основные достоинства использования массивов — лёгкость вычисления адреса элемента по его индексу (поскольку элементы 
массива располагаются один за другим), одинаковое время доступа ко всем элементам, малый размер элементов (они состоят 
только из информационного поля). Среди недостатков — невозможность удаления или добавления элемента без сдвига других
при использовании статических массивов, а при использовании динамических и гетерогенных массивов — более низкое 
быстродействие из-за накладных расходов на поддержку динамики и разнородности. При работе с массивами с реализацией 
по типу языка Си (с указателями) и отсутствии дополнительных средств контроля типичной ошибкой времени выполнения 
является угроза выхода за границы массива и повреждения данных

#### Динамический массив
Динамическими называются массивы, размер которых может изменяться во время выполнения программы. Обычные 
(не динамические) массивы называют ещё фиксированными или статическими.

Динамические массивы могут реализовываться как на уровне языка программирования, так и на уровне системных библиотек. 
Во втором случае динамический массив представляет собой объект стандартной библиотеки, и все операции с ним 
реализуются в рамках той же библиотеки

### Множество
Тип и структура данных в информатике, которая является реализацией математического объекта множество.

Данные типа множество позволяют хранить ограниченное число значений определённого типа без определённого порядка. 
Повторение значений, как правило, недопустимо. За исключением того, что множество в программировании конечно, оно
в общем соответствует концепции математического множества. Для этого типа в языках программирования обычно предусмотрены 
стандартные операции над множествами.

В зависимости от идеологии, разные языки программирования рассматривают множество как простой или сложный тип данных.

### Хэш отображение
Хеш-табли́ца (англ. hash-table) — структура данных, реализующая интерфейс ассоциативного массива. В отличие от деревьев 
поиска, реализующих тот же интерфейс, обеспечивают меньшее время отклика в среднем. Представляет собой эффективную 
структуру данных для реализации словарей, а именно, она позволяет хранить пары (ключ, значение) и выполнять три 
операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.

### Связный список
Базовая динамическая структура данных в информатике, состоящая из узлов, содержащих данные и ссылки («связки») на 
следующий и/или предыдущий узел списка. Принципиальным преимуществом перед массивом является структурная гибкость: 
порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, 
а порядок обхода списка всегда явно задаётся его внутренними связями.

**Виды**
- Односвязный список (однонаправленный связный список)
- Двусвязный список (двунаправленный связный список)
- XOR-связный список
- Кольцевой связный список
- Список с пропусками
- Развёрнутый связный список

#### Преимущества
- эффективное (за константное время) добавление и удаление элементов
- размер ограничен только объёмом памяти компьютера и разрядностью указателей
- динамическое добавление и удаление элементов

#### Недостатки
- сложность прямого доступа к элементу, а именно определения физического адреса по его индексу (порядковому номеру) в 
списке
- на поля-указатели (указатели на следующий и предыдущий элемент) расходуется дополнительная память (в массивах, 
например, указатели не нужны)
- некоторые операции со списками медленнее, чем с массивами, так как к произвольному элементу списка можно обратиться, 
только пройдя все предшествующие ему элементы
- соседние элементы списка могут быть распределены в памяти нелокально, что снизит эффективность кэширования данных в 
процессоре
- над связными списками, по сравнению с массивами, гораздо труднее (хоть и возможно) производить параллельные векторные 
операции, такие, как вычисление суммы: накладные расходы на перебор элементов снижают эффективность распараллеливания

### Стек
Структура данных, представляющая из себя упорядоченный набор элементов, в которой добавление новых элементов и удаление 
существующих производится с одного конца, называемого вершиной стека. Притом первым из стека удаляется элемент, который 
был помещен туда последним, то есть в стеке реализуется стратегия «последним вошел — первым вышел» (last-in, first-out 
— LIFO). Примером стека в реальной жизни может являться стопка тарелок: когда мы хотим вытащить тарелку, мы должны снять 
все тарелки выше.   
Вернемся к описанию операций стека:
- проверка стека на наличие в нем элементов,
- запись в стек — операция вставки нового элемента,
- снятие со стека — операция удаления нового элемента.

#### Варианты реализации
- на массиве
- на саморасширяющемся массиве
- на списке

### Очередь
Структура данных, добавление и удаление элементов в которой происходит путём операций push и pop соответственно. 
Притом первым из очереди удаляется элемент, который был помещен туда первым, то есть в очереди реализуется принцип
«первым вошел — первым вышел» (англ. first-in, first-out — FIFO). У очереди имеется голова (англ. head) и хвост 
(англ. tail). Когда элемент ставится в очередь, он занимает место в её хвосте. Из очереди всегда выводится элемент, 
который находится в ее голове.   
Очередь поддерживает следующие операции:
- empty - проверка очереди на наличие в ней элементов
- push - операция вставки нового элемента
- pop - операция удаления нового элемента
- size - операция получения количества элементов в очереди

### Дерево
Одна из наиболее широко распространённых структур данных в информатике, эмулирующая древовидную структуру в виде набора 
связанных узлов. Является связным графом, не содержащим циклы. Большинство источников также добавляет условие на то, 
что рёбра графа не должны быть ориентированными. В дополнение к этим трём ограничениям, в некоторых источниках 
указывается, что рёбра графа не должны быть взвешенными.
#### Узлы
Узел является экземпляром одного из двух типов элементов графа, соответствующим объекту некоторой фиксированной природы. 
Узел может содержать значение, состояние или представление отдельной информационной структуры или самого дерева. 
Каждый узел дерева имеет ноль или более узлов-потомков, которые располагаются ниже по дереву (по соглашению, деревья 
"растут" вниз, а не вверх, как это происходит с настоящими деревьями). Узел, имеющий потомка, называется узлом-родителем 
относительно своего потомка (или узлом-предшественником, или старшим). Каждый узел имеет не больше одного предка. 
Высота узла — это максимальная длина нисходящего пути от этого узла к самому нижнему узлу (краевому узлу), называемому 
листом. Высота корневого узла равна высоте всего дерева. Глубина вложенности узла равна длине пути до корневого узла.
##### Корневые узлы
Узел, не имеющий предков (самый верхний), называется корневым узлом. Это узел, на котором начинается выполнение 
большинства операций над деревом (хотя некоторые алгоритмы начинают выполнение с «листов» и выполняются, пока не 
достигнут корня). Все прочие узлы могут быть достигнуты путём перехода от корневого узла по рёбрам (или ссылкам) 
(согласно формальному определению, каждый подобный путь должен быть уникальным). В диаграммах он обычно изображается 
на самой вершине. В некоторых деревьях, например, кучах, корневой узел обладает особыми свойствами. Каждый узел дерева 
можно рассматривать как корневой узел поддерева, «растущего» из этого узла.
#### Поддеревья
Поддерево — часть древообразной структуры данных, которая может быть представлена в виде отдельного дерева. Любой узел 
дерева T вместе со всеми его узлами-потомками является поддеревом дерева T. Для любого узла поддерева либо должен быть 
путь в корневой узел этого поддерева, либо сам узел должен являться корневым. То есть поддерево связано с корневым узлом 
целым деревом, а отношения поддерева со всеми прочими узлами определяются через понятие соответствующее поддерево 
(по аналогии с термином «соответствующее подмножество»).
#### Упорядочивание деревьев
Существует два основных типа деревьев. В рекурсивном дереве или неупорядоченном дереве имеет значение лишь структура 
самого дерева без учёта порядка потомков для каждого узла. Дерево, в котором задан порядок (например, каждому ребру, 
ведущему к потомку, присвоены различные натуральные числа) называется деревом с именованными рёбрами или упорядоченным 
деревом со структурой данных, заданной перед именованием и называемой структурой данных упорядоченного дерева.  
Упорядоченные деревья являются наиболее распространёнными среди древовидных структур. Двоичное дерево поиска — одно из
разновидностей упорядоченного дерева.
#### Представление деревьев
Существует множество различных способов представления деревьев. Наиболее общий способ представления изображает узлы как 
записи, расположенные в динамически выделяемой памяти с указателями на своих потомков, предков (или и тех и других), 
или как элементы массива, связанные между собой отношениями, определёнными их позициями в массиве (например, двоичная куча).
##### Деревья как графы
В теории графов дерево — связный ациклический граф. Корневое дерево — это граф с вершиной, выделенной в качестве 
корневой. В этом случае любые две вершины, связанные ребром, наследуют отношения «родитель-потомок». Несвязный граф,
состоящий исключительно из деревьев, называется лесом

### Граф
Граф — нелинейная структура организации данных, которая состоит из «вершин» и «ребер» между ними. Каждая вершина — это 
значение, а ребра — пути, которые соединяют между собой вершины. Получается своеобразная «сетка», похожая на карту дорог 
или созвездие.

Графы бывают неориентированными, когда ребра не имеют конкретного направления, и ориентированными. Во втором случае по 
ребрам можно пройти только в одну сторону — как по дороге с односторонним движением. Есть смешанные графы, в которых 
есть и ориентированные, и неориентированные ребра.

Также существуют взвешенные графы, у ребер которых есть «вес» — то или иное значение. Например, в карте дорог весом 
ребра-дороги можно назвать его длину.

Графы обычно реализуют с помощью связанных списков или матриц — двумерных массивов.
#### Операции
С этими структурами есть базовые операции: добавление вершины или ребра, отображение вершины или графа целиком, 
оценка «стоимости» обхода взвешенного графа и так далее.

Существует несколько алгоритмов обхода графов для поиска информации или для нахождения кратчайшего пути от одной 
вершины до другой. Например, DFS, BFS, алгоритм Дейкстры и другие. Для них не всегда существуют отдельные команды, 
так что реализовать эти алгоритмы может понадобиться самостоятельно.
#### Применение
Графы активно используют для хранения моделей машинного обучения, а также при работе с картами, например, для построения 
маршрутов через онлайн-сервисы. Программное эмулирование электрических цепей — это тоже графы. Также теория графов 
применяется в поисковых алгоритмах и социальных сетях — например, так рассчитывается «охват» друзей одного человека. 
Графы можно использовать для распределения ресурсов внутри системы или при организации сложных вычислений.

## Продвинутые
### Приоритетная очередь
Абстрактная структура данных наподобие стека или очереди, где у каждого элемента есть приоритет. Элемент с более высоким 
приоритетом находится перед элементом с более низким приоритетом. Если у элементов одинаковые приоритеты, они 
располагаются в зависимости от своей позиции в очереди. Обычно приоритетные очереди реализуются с помощью куч (англ. heap).
#### Операции
- findMin или findMax — поиск элемента с наибольшим приоритетом,
- insert или push — вставка нового элемента,
- extractMin или extractMax — извлечь элемент с наибольшим приоритетом,
- deleteMin или deleteMax — удалить элемент с наибольшим приоритетом,
- increaseKey или decreaseKey — обновить значение элемента,
- merge — объединение двух приоритетных очередей, сохраняя оригинальные очереди,
- meld — объединение двух приоритетных очередей, разрушая оригинальные очереди,
- split — разбить приоритную очередь на две части.
#### Реализации
##### Наивная
В качестве наивной реализации мы можем взять обычный список и при добавлении нового элемента класть его в конец, а 
при запросе элемента с максимальным приоритетом проходить по всему списку. Тогда операция insert
будет выполняться за O(1), а extractMin или extractMax за O(n) .
##### Обычная
Для лучшей производительности приоритетные очереди реализуют с помощью куч, что позволяет выполнять операции вставки и 
удаления за O(logn).
Использование специальных куч, таких как Фибоначчиева куча и спаренная куча, позволяет еще больше улучшить асимптотику 
некоторый операций.
### LRU Cache
Алгоритм для хранения ограниченного объема данных: из хранилища вытесняется информация, которая не использовалась 
дольше всего. Его применяют при организации кэша.  

Алгоритм LRU оставляет в кэше данные, которые использовались недавно, а те, к которым обращались давно, вытесняет.
### Бинарные деревья
#### Бинарное дерево поиска
Дерево, обладающее дополнительными свойствами: значение левого потомка меньше значения родителя, а значение правого
потомка больше значения родителя для каждого узла дерева. То есть, данные в бинарном дереве поиска хранятся в 
отсортированном виде. При каждой операции вставки нового или удаления существующего узла отсортированный порядок 
дерева сохраняется. При поиске элемента сравнивается искомое значение с корнем. Если искомое больше корня, то поиск 
продолжается в правом потомке корня, если меньше, то в левом, если равно, то значение найдено и поиск прекращается.
#### Сбалансированное бинарное дерево поиска
Сбалансированное бинарное дерево поиска — это бинарное дерево поиска с логарифмической высотой. Данное определение 
скорее идейное, чем строгое. Строгое определение оперирует разницей глубины самого глубокого и самого неглубокого листа 
(в AVL-деревьях) или отношением глубины самого глубокого и самого неглубокого листа (в красно-черных деревьях). 
В сбалансированном бинарном дереве поиска операции поиска, вставки и удаления выполняются за логарифмическое время 
(так как путь к любому листу от корня не более логарифма). В вырожденном случае несбалансированного бинарного дерева 
поиска, например, когда в пустое дерево вставлялась отсортированная последовательность, дерево превратится в линейный 
список, и операции поиска, вставки и удаления будут выполняться за линейное время. Поэтому балансировка дерева крайне 
важна. Технически балансировка осуществляется поворотами частей дерева при вставке нового элемента, если вставка данного
элемента нарушила условие сбалансированности.

### Непересекающиеся множества
Структура данных для эффективной работы с непересекающимися множествами (каждый элемент принадлежит только к одному 
множеству), позволяющий проверять, принадлежат ли два элемента к одинаковому множеству, и объединять множества.  

СНМ часто называют DSU, от англ. Disjoint Set Union, хотя DSU - это название только операции объединения (Union). 
Впрочем, эта аббревиатура уже устоялась в олимпиадном программировании, поэтому она будет использоваться далее.

DSU представляет собой набор корневых деревьев (лес). Каждое дерево соответствует определённому множеству. При 
реализации DSU необходимо лишь подниматься вверх по деревьям, поэтому достаточно хранить для каждой вершины только 
номер её прямого предка. Для этого используется массив p.

Для описания множества используется номер вершины, являющейся корнем соответствующего дерева. Поэтому для определения, 
принадлежат ли два элемента к одному и тому же множеству, для каждого элемента нужно найти корень соответствующего 
дерева (поднимаясь вверх пока это возможно) и сравнить эти корни.

Объединяются множества элементарно. Пусть нам нужно объединить множества с корнями a и b. Просто присвоим p[a]=b, 
тем самым подвесив всё дерево **a** к корню дерева b.
### Префиксное и нагруженные деревья
Структура данных, позволяющая хранить ассоциативный массив, ключами которого чаще всего являются строки. Представляет 
собой корневое дерево, каждое ребро которого помечено каким-то символом так, что для любого узла все рёбра, соединяющие 
этот узел с его сыновьями, помечены разными символами. Некоторые узлы префиксного дерева выделены (на рисунке они 
подписаны цифрами) и считается, что префиксное дерево содержит данную строку-ключ тогда и только тогда, когда эту 
строку можно прочитать на пути из корня до некоторого (единственного для этой строки) выделенного узла. В некоторых 
приложениях удобно считать все узлы дерева выделенными.

Таким образом, в отличие от бинарных деревьев поиска, ключ, идентифицирующий конкретный узел дерева, не явно хранится
в данном узле, а задаётся положением данного узла в дереве. Получить ключ можно выписыванием подряд символов, 
помечающих рёбра на пути от корня до узла. Ключ корня дерева — пустая строка. Часто в выделенных узлах хранят 
дополнительную информацию, связанную с ключом, и обычно выделенными являются только листья и, возможно, некоторые 
внутренние узлы.
#### Основные операции
- проверка наличия ключа в дереве
- удаление ключа из дерева
- ставка нового ключа

### Список с пропусками
Вероятностная структура данных, основанная на нескольких параллельных отсортированных связных списках с эффективностью,
сравнимой с двоичным деревом (порядка O(log n) среднее время для большинства операций).

В основе списка с пропусками лежит расширение отсортированного связного списка дополнительными связями, добавленными в 
случайных путях с геометрическим/негативным биномиальным распределением, таким образом, чтобы поиск по списку мог 
быстро пропускать части этого списка. Вставка, поиск и удаление выполняются за логарифмическое случайное время.
#### Описание
Список с пропусками — это несколько слоев. Нижний слой — это обычный упорядоченный связный список. Каждый более 
высокий слой представляет собой «выделенную полосу движения» для списков ниже, где элемент в i-м слое появляется 
в i+1-м слое с некоторой фиксированной вероятностью p (два наиболее часто используемых значений для p — 1/2 и 1/4). 
В среднем каждый элемент встречается в 1/(1-p) списках, и верхний элемент (обычно специальный головной элемент в
начале списка с пропусками) в log _1/p_ N списках.
Поиск нужного элемента начинается с головного элемента верхнего списка, и выполняется горизонтально до тех пор, пока 
текущий элемент не станет больше либо равен целевому. Если текущий элемент равен целевому, он найден. Если текущий 
элемент больше, чем целевой, процедура повторяется после возвращения к предыдущему элементу и спуска вниз вертикально 
на следующий нижележащий список. Ожидаемое число шагов в каждом связном списке 1/p, что можно увидеть, просматривая 
путь поиска назад с целевого элемента, пока не будет достигнут элемент, который появляется в следующем более высоком 
списке. Таким образом, общие ожидаемые затраты на поиск — (log _1/p_ N )/2, равные O(log n) в случае константного p. 
Выбирая разные значения p, возможно выбирать необходимый компромисс между затратами на время поиска и затратами памяти
на хранение списка.