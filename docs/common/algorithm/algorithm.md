## Общая информация
- [Сравнительная таблица сложности алгоритмов](https://www.bigocheatsheet.com/)  

## Основные алгоритмы 

### Бинарный поиск
#### Описание
Алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины. 
Используется в информатике, вычислительной математике и математическом программировании.

Частным случаем двоичного поиска является метод бисекции, который применяется для поиска корней заданной непрерывной 
функции на заданном отрезке.

#### Реализация
1. Определение значения элемента в середине структуры данных. Полученное значение сравнивается с ключом.
2. Если ключ меньше значения середины, то поиск осуществляется в первой половине элементов, иначе — во второй.
3. Поиск сводится к тому, что вновь определяется значение серединного элемента в выбранной половине и сравнивается с 
ключом.
4. Процесс продолжается до тех пор, пока не будет найден элемент со значением ключа или не станет пустым интервал для 
поиска.
#### Пример
![binary-search](gifs/binary-search.gif)
##### [Golang](golang-examples/binary-search/main.go)

### Сортировки пузырьком
#### Описание
Этот алгоритм — простейший, но эффективен он лишь для небольших массивов. Сложность алгоритма: O(n^2)

Алгоритм считается учебным и практически не применяется вне учебной литературы, вместо него на практике применяются 
более эффективные алгоритмы сортировки. В то же время метод сортировки обменами лежит в основе некоторых более 
совершенных алгоритмов, таких как шейкерная сортировка, пирамидальная сортировка и быстрая сортировка.    

Как частный пример существует в виде "шейкерной сортировки", когда после того, как масимальный элемент выдавлен на край 
массива, указатели начинают идти в обратную сторону.
#### Реализация
Алгоритм состоит в повторяющихся проходах по сортируемому массиву. На каждой итерации последовательно сравниваются 
соседние элементы, и, если порядок в паре неверный, то элементы меняют местами. За каждый проход по массиву как минимум 
один элемент встает на свое место, поэтому необходимо совершить не более n−1
проходов, где n размер массива, чтобы отсортировать массив.
#### Пример
![bubble-sort](gifs/bubble-sort.gif)
##### [Golang](golang-examples/bubble-sort/main.go)

### Сортировка выбором
#### Описание
Алгоритм сортировки со сложностью O(n^2), где n — количество элементов для сортировки.
#### Реализация
На каждом i-ом шаге алгоритма находим i-ый минимальный элемент и меняем его местами 
с i-ым элементом в массиве. Таким образом будет получен массив, отсортированный по возрастанию.
#### Пример
![selection-sort](gifs/selection-sort.gif)
##### [Golang](golang-examples/selection-sort/main.go)

### Сортировка вставками
#### Описание
Элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в 
подходящее место среди ранее упорядоченных элементов. Сложность O(n^2).
Есть несколько вариантов оптимизаций: бинарная и двухпутевые
#### Реализация
Каждый элемент в линейном обходе массива перемещается в отсортированную часть, где занимает место согласно своим весам.
#### Пример
![insert-search](gifs/insert-sort.gif)
##### [Golang](golang-examples/insert-sort/main.go)

### Быстрая сортировка
#### Описание
Основывается на принципе "разделяй и властвуй". Он работает путем выбора элемента из массива, называемого опорным 
элементом, и перемещения всех элементов, которые меньше опорного элемента, влево от него, а все элементы, которые 
больше опорного элемента, перемещаются вправо. Затем процесс повторяется рекурсивно для каждой из двух полученных 
половинок массива.
Сложность O(n log n).  
В худшем случае O(n^2)
#### Реализация
Алгоритм быстрой сортировки начинается с проверки длины массива. Если массив содержит менее двух элементов, то он уже 
отсортирован, и функция возвращает его как есть.  
Затем выбирается опорный элемент путем выбора случайного индекса в массиве. Он перемещается в конец массива, и 
происходит разделение массива на две части: элементы, которые меньше опорного, и элементы, которые больше опорного.  
Элементы, которые меньше опорного, перемещаются в левую часть массива, а элементы, которые больше опорного, перемещаются
в правую часть массива. Затем процесс повторяется рекурсивно для каждой из двух полученных половинок массива.  
Когда размер каждой половины массива становится меньше двух, функция возвращает отсортированный массив.
#### Пример
![quick-search](gifs/quick-sort.gif)
##### [Golang](golang-examples/quick-sort/main.go)

### Сортировка слиянием
#### Описание
Алгоритм сортировки, использующий O(n) дополнительной памяти и работающий за O(nlog(n)) времени.
#### Реализация
1. Если в рассматриваемом массиве один элемент, то он уже отсортирован — алгоритм завершает работу.
2. Иначе массив разбивается на две части, которые сортируются рекурсивно.
3. После сортировки двух частей массива к ним применяется процедура слияния, которая по двум отсортированным частям 
получает исходный отсортированный массив.
#### Пример
![quick-search](gifs/merge-sort.gif)
##### [Golang](golang-examples/merge-sort/main.go)

### Кодирование Хаффмена
#### Описание
Алгоритм оптимального префиксного кодирования алфавита. Был разработан в 1952 году аспирантом Массачусетского 
технологического института Дэвидом Хаффманом при написании им курсовой работы. Используется во многих программах 
сжатия данных, например, PKZIP 2, LZH и др
#### Реализация
1. Составим список кодируемых символов, при этом будем рассматривать один символ как дерево, состоящее из одного элемента 
c весом, равным частоте появления символа в строке.
2. Из списка выберем два узла с наименьшим весом.
3. Сформируем новый узел с весом, равным сумме весов выбранных узлов, и присоединим к нему два выбранных узла в качестве детей.
4. Добавим к списку только что сформированный узел вместо двух объединенных узлов.
5. Если в списке больше одного узла, то повторим пункты со второго по пятый.
#### Пример
![quick-search](gifs/huffman.gif)
##### [Golang](golang-examples/huffman/main.go)

### Поиск в ширину
#### Описание
Один из простейших алгоритмов обхода графа, являющийся основой для многих важных алгоритмов для работы с графами
#### Реализация
Алгоритм должен пройти по каждому уровню дерева углубляясь ниже только когда на текущем уровне закончаться узлыиаы
#### Пример
![quick-search](gifs/bfs.gif)
##### [Golang](golang-examples/bfs/main.go)

### Поиск в глубину
#### Описание
Стратегия поиска в глубину, как и следует из названия, состоит в том, чтобы идти «вглубь» графа, насколько это возможно.
#### Реализация
Алгоритм поиска описывается рекурсивно: перебираем все исходящие из рассматриваемой вершины рёбра. Если ребро ведёт в 
вершину, которая не была рассмотрена ранее, то запускаем алгоритм от этой нерассмотренной вершины, а после возвращаемся 
и продолжаем перебирать рёбра. Возврат происходит в том случае, если в рассматриваемой вершине не осталось рёбер, 
которые ведут в нерассмотренную вершину. Если после завершения алгоритма не все вершины были рассмотрены, то необходимо 
запустить алгоритм от одной из нерассмотренных вершин
#### Пример
![quick-search](gifs/dfs.gif)
##### [Golang](golang-examples/dfs/main.go)

### Градиентный спуск
#### Описание
Способ оптимизации функций, основанный на вычислениях. В контексте машинного обучения или регрессии это значит 
нахождение значений весов алгоритма ML, минимизирующих ошибку в предсказаниях. И хотя математически он более сложен, 
чем остальные алгоритмы, при работе с данными и предсказаниями понимание его работы имеет огромное значение.
#### Реализация
Необходимо создать функцию и её производную.  
Определяем функцию, которая будет выполнять градиентный спуск на указанное количество итераций с заданным шагом.  
Более подробно о спуске лучше почитать в статьях о машинном обучении.
#### Пример
![quick-search](gifs/gradient.gif)
##### [Golang](golang-examples/gradient/main.go)

### Алгоритм Дейкстры
#### Описание
Cпособ поиска кратчайшего пути между узлами в графе. Он является базой в задачах поиска пути и находит широкое 
применение начиная с искусственного интеллекта и заканчивая созданием игр.
#### Реализация

![quick-search](gifs/dijkstra.gif)
##### [Golang](golang-examples/dijkstra/main.go)

### Обмен ключами Диффи Хеллмана
#### Описание
Он работает путем объединения открытых и закрытых ключей (которые представляют из себя очень длинные числа) для 
шифрования информации, передаваемой между двумя различными сторонами.
#### Реализация

![quick-search](gifs/diffie-hellman.gif)
##### [Golang](golang-examples/diffie-hellman/main.go)
