## Прокотолы 

### UDP/TCP
#### UDP
Транспортный протокол, передающий сообщения-дата граммы без необходимости установки соединения в IP-сети.  
Не требует отклика от клиента и допускает потери пакетов при передаче данных.

#### TCP
Транспортный протокол передачи данных в сетях TCP/IP, предварительно устанавливающий соединение с сетью.  
Требует заранее установленного соединения и позволяет контролировать процесс передачи данных.

#### Отличия
- TCP гарантирует доставку пакетов данных в неизменных виде, последовательности и без потерь, UDP ничего не гарантирует.
- TCP нумерует пакеты при передаче, а UDP нет
- TCP работает в дуплексном режиме, в одном пакете можно отправлять информацию и подтверждать получение предыдущего пакета.
- TCP требует заранее установленного соединения, UDP соединения не требует, у него это просто поток данных.
- UDP обеспечивает более высокую скорость передачи данных.
- TCP надежнее и осуществляет контроль над процессом обмена данными.
- UDP предпочтительнее для программ, воспроизводящих потоковое видео, виде/телефонии, сетевых игр.
- UPD не содержит функций восстановления данных

### HTTP
[Коротко об HTTP](https://habr.com/ru/post/215117)  
[Разница версий HTTP](https://hostiq.ua/wiki/http-https)

Главное отличие HTTP (:80) от HTTPS (:443), что второй – надстройка над первым, которая использует защищенный протокол для передачи данных.   
Защита обеспечивается с помощью SSL сертификата

- Какие типы бывают и для чего предназначены
  - OPTIONS - Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса
  - GET - Используется для запроса содержимого указанного ресурса
  - HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело, используется для извлечения метаданных
  - POST - Применяется для передачи пользовательских данных заданному ресурсу
  - PUT - Применяется для загрузки содержимого запроса на указанный в запросе URI
  - PATCH - Аналогично PUT, но применяется только к фрагменту ресурса
  - DELETE - Удаляет указанный ресурс
  - TRACE - Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе
  - CONNECT - Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси
- Коды запросов
  - 1хх – Информационный
  - 2хх – Успешный
  - 3хх – Перенаправление
  - 4хх – Ошибка на стороне клиента
  - 5хх – Ошибка на стороне сервера
### Protocol buffers

[Описание на wiki](https://ru.wikipedia.org/wiki/Protocol_Buffers)  
Протокол сериализации данных, предложенный, как альтернатива устаревшему XML.  
Согласно заданным правилам формируется описание для структур данных, которое позволяет сгенерировать методы сериализации/десириализации объекта в нужном языке программирования.
На текущий момент большая часть всех популярных языков программирования имеет реализованные инструменты для работы с ним

### SOAP
Протокол обмена структурированными сообщениями в распределённой вычислительной среде
- Первоначально SOAP предназначался в основном для реализации удалённого вызова процедур (RPC)
- Сейчас протокол используется для обмена произвольными сообщениями в формате XML
- Использование SOAP для передачи сообщений увеличивает их объём и снижает скорость обработки. В системах, где скорость важна, чаще используется пересылка XML-документов через HTTP напрямую, где параметры запроса передаются как обычные HTTP-параметры.

[Описание на wiki](https://ru.wikipedia.org/wiki/SOAP)

### GRPC
[Описание на wiki](https://ru.wikipedia.org/wiki/GRPC)  
[Статья на habr](https://habr.com/ru/company/intel/blog/165903/)  
[Примеры использования на GOLANG](https://golang.hotexamples.com/ru/examples/github.com.dorzheh.deployer.utils.hwinfo.host/NUMA/-/golang-numa-class-examples.html)

Система удалённого вызова процедур, даже с учётом кроссплатформенности используемых технологий.  
Транспорт - http/2  
Язык описание интерфейсов - protocol buffers

Типы методов обслуживания:
- Унарный RPC (Unary RPC) — клиент отправляет один запрос на сервер и получает один ответ обратно, как при обычном вызове функции.
- Серверные потоковые RPC (Server streaming RPC), когда клиент отправляет запрос на сервер и получает поток для чтения последовательности сообщений обратно. Клиент читает из возвращенного потока, пока не кончатся сообщения. gRPC гарантирует упорядочение сообщений в рамках отдельного вызова RPC.
- Клиентские потоковые RPC (Client streaming RPC), в которых клиент записывает последовательность сообщений и отправляет их на сервер, снова используя предоставленный поток. После того, как клиент закончил писать сообщения, он ждет, пока сервер прочитает их и вернет свой ответ. Опять же, gRPC гарантирует упорядочение сообщений в рамках отдельного вызова RPC.
- RPC с двунаправленной потоковой передачей (Bidirectional streaming RPC), где обе стороны отправляют последовательность сообщений, используя поток чтения-записи. Два потока работают независимо, поэтому клиенты и серверы могут читать и писать в любом порядке: например, сервер может дождаться получения всех клиентских сообщений, прежде чем записывать свои ответы, или он может поочередно читать сообщение, а затем писать сообщение, или какая-то другая комбинация чтения и записи. Порядок сообщений в каждом потоке сохраняется.

### SSL/TLS
__SSL__ или слой защищенных сокетов было оригинальным названием протокола, который разработала компания Netscape в середине 90-х.
SSL 1.0 никогда не был публично доступным, а в версии 2.0 были серьезные недостатки.
Протокол SSL 3.0, выпущенный в 1996, был полностью переделан и задал тон следующей стадии развития.

Когда следующую версию протокола выпустили в 1999, ее стандартизировала специальная рабочая группа проектирования сети Интернет и дала ей новое название: защита транспортного уровня, или TLS.
Как говорится в TLS-документации, «разница между этим протоколом и SSL 3.0 не критичная».
TLS и SSL формируют постоянно обновляемую серию протоколов, и их часто объединяют под названием __SSL/TLS__.

Протокол TLS шифрует интернет-трафик любого вида. Самый распространенный вид — веб-трафик.
Вы знаете, когда ваш браузер устанавливает соединение по TLS — если ссылка в адресной строке начинается с «https».

TLS также используется другими приложениями — например, в почте и системах телеконференций.

Самый безопасный метод шифрования — это асимметричное шифрование. Для этого требуется 2 ключа, 1 публичный и 1 приватный.
Это файлы с информацией, чаще всего очень большие числа.
Механизм сложный, но если попросту, вы можете использовать публичный ключ, чтобы шифровать данные, но вам нужен приватный ключ, чтобы расшифровывать их.
Два ключа связаны с помощью сложной математической формулы, которую сложно хакнуть.

Так как в асимметричном шифровании применяются сложные математические расчеты, нужно много вычислительных ресурсов.
TLS решает эту проблему, используя асимметричное шифрование только в начале сессии, чтобы зашифровать общение между сервером и клиентом.
Сервер и клиент должны договориться об одном ключе сессии, который они будут вдвоем использовать, чтобы зашифровать пакеты данных.

### NAT

Сети обычно проектируются с использованием частных IP адресов.
Это адреса __10.0.0.0/8__, __172.16.0.0/12__ и __192.168.0.0/16__.
Эти частные адреса используются внутри организации или площадки, чтобы позволить устройствам общаться локально, и они не маршрутизируются в интернете.
Чтобы позволить устройству с приватным IPv4-адресом обращаться к устройствам и ресурсам за пределами локальной сети, приватный адрес сначала должен быть переведен на общедоступный публичный адрес.

И вот как раз NAT переводит приватные адреса, в общедоступные.
Это позволяет устройству с частным адресом IPv4 обращаться к ресурсам за пределами его частной сети. NAT в сочетании с частными адресами IPv4 оказался полезным методом сохранения общедоступных IPv4-адресов.
Один общедоступный IPv4-адрес может быть использован сотнями, даже тысячами устройств, каждый из которых имеет частный IPv4-адрес.
NAT имеет дополнительное преимущество, заключающееся в добавлении степени конфиденциальности и безопасности в сеть, поскольку он скрывает внутренние IPv4-адреса из внешних сетей.
